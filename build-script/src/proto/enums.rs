// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `enums.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TikTok.AuditStatus)
pub enum AuditStatus {
    // @@protoc_insertion_point(enum_value:TikTok.AuditStatus.AUDITSTATUSUNKNOWN)
    AUDITSTATUSUNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:TikTok.AuditStatus.AUDITSTATUSPASS)
    AUDITSTATUSPASS = 1,
    // @@protoc_insertion_point(enum_value:TikTok.AuditStatus.AUDITSTATUSFAILED)
    AUDITSTATUSFAILED = 2,
    // @@protoc_insertion_point(enum_value:TikTok.AuditStatus.AUDITSTATUSREVIEWING)
    AUDITSTATUSREVIEWING = 3,
    // @@protoc_insertion_point(enum_value:TikTok.AuditStatus.AUDITSTATUSFORBIDDEN)
    AUDITSTATUSFORBIDDEN = 4,
}

impl ::protobuf::Enum for AuditStatus {
    const NAME: &'static str = "AuditStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AuditStatus> {
        match value {
            0 => ::std::option::Option::Some(AuditStatus::AUDITSTATUSUNKNOWN),
            1 => ::std::option::Option::Some(AuditStatus::AUDITSTATUSPASS),
            2 => ::std::option::Option::Some(AuditStatus::AUDITSTATUSFAILED),
            3 => ::std::option::Option::Some(AuditStatus::AUDITSTATUSREVIEWING),
            4 => ::std::option::Option::Some(AuditStatus::AUDITSTATUSFORBIDDEN),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<AuditStatus> {
        match str {
            "AUDITSTATUSUNKNOWN" => ::std::option::Option::Some(AuditStatus::AUDITSTATUSUNKNOWN),
            "AUDITSTATUSPASS" => ::std::option::Option::Some(AuditStatus::AUDITSTATUSPASS),
            "AUDITSTATUSFAILED" => ::std::option::Option::Some(AuditStatus::AUDITSTATUSFAILED),
            "AUDITSTATUSREVIEWING" => ::std::option::Option::Some(AuditStatus::AUDITSTATUSREVIEWING),
            "AUDITSTATUSFORBIDDEN" => ::std::option::Option::Some(AuditStatus::AUDITSTATUSFORBIDDEN),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AuditStatus] = &[
        AuditStatus::AUDITSTATUSUNKNOWN,
        AuditStatus::AUDITSTATUSPASS,
        AuditStatus::AUDITSTATUSFAILED,
        AuditStatus::AUDITSTATUSREVIEWING,
        AuditStatus::AUDITSTATUSFORBIDDEN,
    ];
}

impl ::protobuf::EnumFull for AuditStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("AuditStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for AuditStatus {
    fn default() -> Self {
        AuditStatus::AUDITSTATUSUNKNOWN
    }
}

impl AuditStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AuditStatus>("AuditStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TikTok.EmoteType)
pub enum EmoteType {
    // @@protoc_insertion_point(enum_value:TikTok.EmoteType.EMOTETYPENORMAL)
    EMOTETYPENORMAL = 0,
    // @@protoc_insertion_point(enum_value:TikTok.EmoteType.EMOTETYPEWITHSTICKER)
    EMOTETYPEWITHSTICKER = 1,
}

impl ::protobuf::Enum for EmoteType {
    const NAME: &'static str = "EmoteType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EmoteType> {
        match value {
            0 => ::std::option::Option::Some(EmoteType::EMOTETYPENORMAL),
            1 => ::std::option::Option::Some(EmoteType::EMOTETYPEWITHSTICKER),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EmoteType> {
        match str {
            "EMOTETYPENORMAL" => ::std::option::Option::Some(EmoteType::EMOTETYPENORMAL),
            "EMOTETYPEWITHSTICKER" => ::std::option::Option::Some(EmoteType::EMOTETYPEWITHSTICKER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EmoteType] = &[
        EmoteType::EMOTETYPENORMAL,
        EmoteType::EMOTETYPEWITHSTICKER,
    ];
}

impl ::protobuf::EnumFull for EmoteType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EmoteType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EmoteType {
    fn default() -> Self {
        EmoteType::EMOTETYPENORMAL
    }
}

impl EmoteType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EmoteType>("EmoteType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TikTok.ContentSource)
pub enum ContentSource {
    // @@protoc_insertion_point(enum_value:TikTok.ContentSource.CONTENTSOURCEUNKNOWN)
    CONTENTSOURCEUNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:TikTok.ContentSource.CONTENTSOURCENORMAL)
    CONTENTSOURCENORMAL = 1,
    // @@protoc_insertion_point(enum_value:TikTok.ContentSource.CONTENTSOURCECAMERA)
    CONTENTSOURCECAMERA = 2,
}

impl ::protobuf::Enum for ContentSource {
    const NAME: &'static str = "ContentSource";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ContentSource> {
        match value {
            0 => ::std::option::Option::Some(ContentSource::CONTENTSOURCEUNKNOWN),
            1 => ::std::option::Option::Some(ContentSource::CONTENTSOURCENORMAL),
            2 => ::std::option::Option::Some(ContentSource::CONTENTSOURCECAMERA),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ContentSource> {
        match str {
            "CONTENTSOURCEUNKNOWN" => ::std::option::Option::Some(ContentSource::CONTENTSOURCEUNKNOWN),
            "CONTENTSOURCENORMAL" => ::std::option::Option::Some(ContentSource::CONTENTSOURCENORMAL),
            "CONTENTSOURCECAMERA" => ::std::option::Option::Some(ContentSource::CONTENTSOURCECAMERA),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ContentSource] = &[
        ContentSource::CONTENTSOURCEUNKNOWN,
        ContentSource::CONTENTSOURCENORMAL,
        ContentSource::CONTENTSOURCECAMERA,
    ];
}

impl ::protobuf::EnumFull for ContentSource {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ContentSource").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ContentSource {
    fn default() -> Self {
        ContentSource::CONTENTSOURCEUNKNOWN
    }
}

impl ContentSource {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ContentSource>("ContentSource")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TikTok.EmotePrivateType)
pub enum EmotePrivateType {
    // @@protoc_insertion_point(enum_value:TikTok.EmotePrivateType.EMOTE_PRIVATE_TYPE_NORMAL)
    EMOTE_PRIVATE_TYPE_NORMAL = 0,
    // @@protoc_insertion_point(enum_value:TikTok.EmotePrivateType.EMOTE_PRIVATE_TYPE_SUB_WAVE)
    EMOTE_PRIVATE_TYPE_SUB_WAVE = 1,
}

impl ::protobuf::Enum for EmotePrivateType {
    const NAME: &'static str = "EmotePrivateType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EmotePrivateType> {
        match value {
            0 => ::std::option::Option::Some(EmotePrivateType::EMOTE_PRIVATE_TYPE_NORMAL),
            1 => ::std::option::Option::Some(EmotePrivateType::EMOTE_PRIVATE_TYPE_SUB_WAVE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EmotePrivateType> {
        match str {
            "EMOTE_PRIVATE_TYPE_NORMAL" => ::std::option::Option::Some(EmotePrivateType::EMOTE_PRIVATE_TYPE_NORMAL),
            "EMOTE_PRIVATE_TYPE_SUB_WAVE" => ::std::option::Option::Some(EmotePrivateType::EMOTE_PRIVATE_TYPE_SUB_WAVE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EmotePrivateType] = &[
        EmotePrivateType::EMOTE_PRIVATE_TYPE_NORMAL,
        EmotePrivateType::EMOTE_PRIVATE_TYPE_SUB_WAVE,
    ];
}

impl ::protobuf::EnumFull for EmotePrivateType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EmotePrivateType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EmotePrivateType {
    fn default() -> Self {
        EmotePrivateType::EMOTE_PRIVATE_TYPE_NORMAL
    }
}

impl EmotePrivateType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EmotePrivateType>("EmotePrivateType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TikTok.TextType)
pub enum TextType {
    // @@protoc_insertion_point(enum_value:TikTok.TextType.DISPLAY_TEXT)
    DISPLAY_TEXT = 0,
    // @@protoc_insertion_point(enum_value:TikTok.TextType.CONTENT)
    CONTENT = 1,
}

impl ::protobuf::Enum for TextType {
    const NAME: &'static str = "TextType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TextType> {
        match value {
            0 => ::std::option::Option::Some(TextType::DISPLAY_TEXT),
            1 => ::std::option::Option::Some(TextType::CONTENT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<TextType> {
        match str {
            "DISPLAY_TEXT" => ::std::option::Option::Some(TextType::DISPLAY_TEXT),
            "CONTENT" => ::std::option::Option::Some(TextType::CONTENT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TextType] = &[
        TextType::DISPLAY_TEXT,
        TextType::CONTENT,
    ];
}

impl ::protobuf::EnumFull for TextType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TextType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TextType {
    fn default() -> Self {
        TextType::DISPLAY_TEXT
    }
}

impl TextType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TextType>("TextType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TikTok.LinkmicApplierSortSetting)
pub enum LinkmicApplierSortSetting {
    // @@protoc_insertion_point(enum_value:TikTok.LinkmicApplierSortSetting.LINKMIC_APPLIER_SORT_SETTING_NONE)
    LINKMIC_APPLIER_SORT_SETTING_NONE = 0,
    // @@protoc_insertion_point(enum_value:TikTok.LinkmicApplierSortSetting.LINKMIC_APPLIER_SORT_SETTING_BY_GIFT_SCORE)
    LINKMIC_APPLIER_SORT_SETTING_BY_GIFT_SCORE = 1,
}

impl ::protobuf::Enum for LinkmicApplierSortSetting {
    const NAME: &'static str = "LinkmicApplierSortSetting";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LinkmicApplierSortSetting> {
        match value {
            0 => ::std::option::Option::Some(LinkmicApplierSortSetting::LINKMIC_APPLIER_SORT_SETTING_NONE),
            1 => ::std::option::Option::Some(LinkmicApplierSortSetting::LINKMIC_APPLIER_SORT_SETTING_BY_GIFT_SCORE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<LinkmicApplierSortSetting> {
        match str {
            "LINKMIC_APPLIER_SORT_SETTING_NONE" => ::std::option::Option::Some(LinkmicApplierSortSetting::LINKMIC_APPLIER_SORT_SETTING_NONE),
            "LINKMIC_APPLIER_SORT_SETTING_BY_GIFT_SCORE" => ::std::option::Option::Some(LinkmicApplierSortSetting::LINKMIC_APPLIER_SORT_SETTING_BY_GIFT_SCORE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LinkmicApplierSortSetting] = &[
        LinkmicApplierSortSetting::LINKMIC_APPLIER_SORT_SETTING_NONE,
        LinkmicApplierSortSetting::LINKMIC_APPLIER_SORT_SETTING_BY_GIFT_SCORE,
    ];
}

impl ::protobuf::EnumFull for LinkmicApplierSortSetting {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("LinkmicApplierSortSetting").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for LinkmicApplierSortSetting {
    fn default() -> Self {
        LinkmicApplierSortSetting::LINKMIC_APPLIER_SORT_SETTING_NONE
    }
}

impl LinkmicApplierSortSetting {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LinkmicApplierSortSetting>("LinkmicApplierSortSetting")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TikTok.HashtagNamespace)
pub enum HashtagNamespace {
    // @@protoc_insertion_point(enum_value:TikTok.HashtagNamespace.GLOBAL)
    GLOBAL = 0,
    // @@protoc_insertion_point(enum_value:TikTok.HashtagNamespace.GAMING)
    GAMING = 1,
}

impl ::protobuf::Enum for HashtagNamespace {
    const NAME: &'static str = "HashtagNamespace";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HashtagNamespace> {
        match value {
            0 => ::std::option::Option::Some(HashtagNamespace::GLOBAL),
            1 => ::std::option::Option::Some(HashtagNamespace::GAMING),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<HashtagNamespace> {
        match str {
            "GLOBAL" => ::std::option::Option::Some(HashtagNamespace::GLOBAL),
            "GAMING" => ::std::option::Option::Some(HashtagNamespace::GAMING),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [HashtagNamespace] = &[
        HashtagNamespace::GLOBAL,
        HashtagNamespace::GAMING,
    ];
}

impl ::protobuf::EnumFull for HashtagNamespace {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("HashtagNamespace").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for HashtagNamespace {
    fn default() -> Self {
        HashtagNamespace::GLOBAL
    }
}

impl HashtagNamespace {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<HashtagNamespace>("HashtagNamespace")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TikTok.AgreeStatus)
pub enum AgreeStatus {
    // @@protoc_insertion_point(enum_value:TikTok.AgreeStatus.AGREE_UNKNOWN)
    AGREE_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:TikTok.AgreeStatus.AGREE)
    AGREE = 1,
    // @@protoc_insertion_point(enum_value:TikTok.AgreeStatus.REJECT)
    REJECT = 2,
}

impl ::protobuf::Enum for AgreeStatus {
    const NAME: &'static str = "AgreeStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AgreeStatus> {
        match value {
            0 => ::std::option::Option::Some(AgreeStatus::AGREE_UNKNOWN),
            1 => ::std::option::Option::Some(AgreeStatus::AGREE),
            2 => ::std::option::Option::Some(AgreeStatus::REJECT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<AgreeStatus> {
        match str {
            "AGREE_UNKNOWN" => ::std::option::Option::Some(AgreeStatus::AGREE_UNKNOWN),
            "AGREE" => ::std::option::Option::Some(AgreeStatus::AGREE),
            "REJECT" => ::std::option::Option::Some(AgreeStatus::REJECT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AgreeStatus] = &[
        AgreeStatus::AGREE_UNKNOWN,
        AgreeStatus::AGREE,
        AgreeStatus::REJECT,
    ];
}

impl ::protobuf::EnumFull for AgreeStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("AgreeStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for AgreeStatus {
    fn default() -> Self {
        AgreeStatus::AGREE_UNKNOWN
    }
}

impl AgreeStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AgreeStatus>("AgreeStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TikTok.KickoutReason)
pub enum KickoutReason {
    // @@protoc_insertion_point(enum_value:TikTok.KickoutReason.KICKOUT_REASON_UNKNOWN)
    KICKOUT_REASON_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:TikTok.KickoutReason.KICKOUT_REASON_FIRST_FRAME_TIMEOUT)
    KICKOUT_REASON_FIRST_FRAME_TIMEOUT = 1,
    // @@protoc_insertion_point(enum_value:TikTok.KickoutReason.KICKOUT_REASON_BY_HOST)
    KICKOUT_REASON_BY_HOST = 2,
    // @@protoc_insertion_point(enum_value:TikTok.KickoutReason.KICKOUT_REASON_RTC_LOST_CONNECTION)
    KICKOUT_REASON_RTC_LOST_CONNECTION = 3,
    // @@protoc_insertion_point(enum_value:TikTok.KickoutReason.KICKOUT_REASON_BY_PUNISH)
    KICKOUT_REASON_BY_PUNISH = 4,
    // @@protoc_insertion_point(enum_value:TikTok.KickoutReason.KICKOUT_REASON_BY_ADMIN)
    KICKOUT_REASON_BY_ADMIN = 5,
    // @@protoc_insertion_point(enum_value:TikTok.KickoutReason.KICKOUT_REASON_HOST_REMOVE_ALL_GUESTS)
    KICKOUT_REASON_HOST_REMOVE_ALL_GUESTS = 6,
}

impl ::protobuf::Enum for KickoutReason {
    const NAME: &'static str = "KickoutReason";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<KickoutReason> {
        match value {
            0 => ::std::option::Option::Some(KickoutReason::KICKOUT_REASON_UNKNOWN),
            1 => ::std::option::Option::Some(KickoutReason::KICKOUT_REASON_FIRST_FRAME_TIMEOUT),
            2 => ::std::option::Option::Some(KickoutReason::KICKOUT_REASON_BY_HOST),
            3 => ::std::option::Option::Some(KickoutReason::KICKOUT_REASON_RTC_LOST_CONNECTION),
            4 => ::std::option::Option::Some(KickoutReason::KICKOUT_REASON_BY_PUNISH),
            5 => ::std::option::Option::Some(KickoutReason::KICKOUT_REASON_BY_ADMIN),
            6 => ::std::option::Option::Some(KickoutReason::KICKOUT_REASON_HOST_REMOVE_ALL_GUESTS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<KickoutReason> {
        match str {
            "KICKOUT_REASON_UNKNOWN" => ::std::option::Option::Some(KickoutReason::KICKOUT_REASON_UNKNOWN),
            "KICKOUT_REASON_FIRST_FRAME_TIMEOUT" => ::std::option::Option::Some(KickoutReason::KICKOUT_REASON_FIRST_FRAME_TIMEOUT),
            "KICKOUT_REASON_BY_HOST" => ::std::option::Option::Some(KickoutReason::KICKOUT_REASON_BY_HOST),
            "KICKOUT_REASON_RTC_LOST_CONNECTION" => ::std::option::Option::Some(KickoutReason::KICKOUT_REASON_RTC_LOST_CONNECTION),
            "KICKOUT_REASON_BY_PUNISH" => ::std::option::Option::Some(KickoutReason::KICKOUT_REASON_BY_PUNISH),
            "KICKOUT_REASON_BY_ADMIN" => ::std::option::Option::Some(KickoutReason::KICKOUT_REASON_BY_ADMIN),
            "KICKOUT_REASON_HOST_REMOVE_ALL_GUESTS" => ::std::option::Option::Some(KickoutReason::KICKOUT_REASON_HOST_REMOVE_ALL_GUESTS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [KickoutReason] = &[
        KickoutReason::KICKOUT_REASON_UNKNOWN,
        KickoutReason::KICKOUT_REASON_FIRST_FRAME_TIMEOUT,
        KickoutReason::KICKOUT_REASON_BY_HOST,
        KickoutReason::KICKOUT_REASON_RTC_LOST_CONNECTION,
        KickoutReason::KICKOUT_REASON_BY_PUNISH,
        KickoutReason::KICKOUT_REASON_BY_ADMIN,
        KickoutReason::KICKOUT_REASON_HOST_REMOVE_ALL_GUESTS,
    ];
}

impl ::protobuf::EnumFull for KickoutReason {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("KickoutReason").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for KickoutReason {
    fn default() -> Self {
        KickoutReason::KICKOUT_REASON_UNKNOWN
    }
}

impl KickoutReason {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<KickoutReason>("KickoutReason")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TikTok.GroupStatus)
pub enum GroupStatus {
    // @@protoc_insertion_point(enum_value:TikTok.GroupStatus.GROUP_STATUS_UNKNOWN)
    GROUP_STATUS_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:TikTok.GroupStatus.GROUP_STATUS_WAITING)
    GROUP_STATUS_WAITING = 1,
    // @@protoc_insertion_point(enum_value:TikTok.GroupStatus.GROUP_STATUS_LINKED)
    GROUP_STATUS_LINKED = 3,
}

impl ::protobuf::Enum for GroupStatus {
    const NAME: &'static str = "GroupStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GroupStatus> {
        match value {
            0 => ::std::option::Option::Some(GroupStatus::GROUP_STATUS_UNKNOWN),
            1 => ::std::option::Option::Some(GroupStatus::GROUP_STATUS_WAITING),
            3 => ::std::option::Option::Some(GroupStatus::GROUP_STATUS_LINKED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<GroupStatus> {
        match str {
            "GROUP_STATUS_UNKNOWN" => ::std::option::Option::Some(GroupStatus::GROUP_STATUS_UNKNOWN),
            "GROUP_STATUS_WAITING" => ::std::option::Option::Some(GroupStatus::GROUP_STATUS_WAITING),
            "GROUP_STATUS_LINKED" => ::std::option::Option::Some(GroupStatus::GROUP_STATUS_LINKED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [GroupStatus] = &[
        GroupStatus::GROUP_STATUS_UNKNOWN,
        GroupStatus::GROUP_STATUS_WAITING,
        GroupStatus::GROUP_STATUS_LINKED,
    ];
}

impl ::protobuf::EnumFull for GroupStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("GroupStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            GroupStatus::GROUP_STATUS_UNKNOWN => 0,
            GroupStatus::GROUP_STATUS_WAITING => 1,
            GroupStatus::GROUP_STATUS_LINKED => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for GroupStatus {
    fn default() -> Self {
        GroupStatus::GROUP_STATUS_UNKNOWN
    }
}

impl GroupStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<GroupStatus>("GroupStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TikTok.BusinessCase)
pub enum BusinessCase {
    // @@protoc_insertion_point(enum_value:TikTok.BusinessCase.BUSINESS_NOT_SET)
    BUSINESS_NOT_SET = 0,
    // @@protoc_insertion_point(enum_value:TikTok.BusinessCase.APPLY_BIZ_CONTENT)
    APPLY_BIZ_CONTENT = 1,
    // @@protoc_insertion_point(enum_value:TikTok.BusinessCase.INVITE_BIZ_CONTENT)
    INVITE_BIZ_CONTENT = 2,
    // @@protoc_insertion_point(enum_value:TikTok.BusinessCase.REPLY_BIZ_CONTENT)
    REPLY_BIZ_CONTENT = 3,
    // @@protoc_insertion_point(enum_value:TikTok.BusinessCase.PERMIT_BIZ_CONTENT)
    PERMIT_BIZ_CONTENT = 4,
    // @@protoc_insertion_point(enum_value:TikTok.BusinessCase.JOIN_DIRECT_BIZ_CONTENT)
    JOIN_DIRECT_BIZ_CONTENT = 5,
    // @@protoc_insertion_point(enum_value:TikTok.BusinessCase.KICK_OUT_BIZ_CONTENT)
    KICK_OUT_BIZ_CONTENT = 6,
    // @@protoc_insertion_point(enum_value:TikTok.BusinessCase.LIST_CHANGE_BIZ_CONTENT)
    LIST_CHANGE_BIZ_CONTENT = 11,
    // @@protoc_insertion_point(enum_value:TikTok.BusinessCase.MULTI_LIVE_CONTENT)
    MULTI_LIVE_CONTENT = 100,
    // @@protoc_insertion_point(enum_value:TikTok.BusinessCase.COHOST_CONTENT)
    COHOST_CONTENT = 200,
}

impl ::protobuf::Enum for BusinessCase {
    const NAME: &'static str = "BusinessCase";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BusinessCase> {
        match value {
            0 => ::std::option::Option::Some(BusinessCase::BUSINESS_NOT_SET),
            1 => ::std::option::Option::Some(BusinessCase::APPLY_BIZ_CONTENT),
            2 => ::std::option::Option::Some(BusinessCase::INVITE_BIZ_CONTENT),
            3 => ::std::option::Option::Some(BusinessCase::REPLY_BIZ_CONTENT),
            4 => ::std::option::Option::Some(BusinessCase::PERMIT_BIZ_CONTENT),
            5 => ::std::option::Option::Some(BusinessCase::JOIN_DIRECT_BIZ_CONTENT),
            6 => ::std::option::Option::Some(BusinessCase::KICK_OUT_BIZ_CONTENT),
            11 => ::std::option::Option::Some(BusinessCase::LIST_CHANGE_BIZ_CONTENT),
            100 => ::std::option::Option::Some(BusinessCase::MULTI_LIVE_CONTENT),
            200 => ::std::option::Option::Some(BusinessCase::COHOST_CONTENT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<BusinessCase> {
        match str {
            "BUSINESS_NOT_SET" => ::std::option::Option::Some(BusinessCase::BUSINESS_NOT_SET),
            "APPLY_BIZ_CONTENT" => ::std::option::Option::Some(BusinessCase::APPLY_BIZ_CONTENT),
            "INVITE_BIZ_CONTENT" => ::std::option::Option::Some(BusinessCase::INVITE_BIZ_CONTENT),
            "REPLY_BIZ_CONTENT" => ::std::option::Option::Some(BusinessCase::REPLY_BIZ_CONTENT),
            "PERMIT_BIZ_CONTENT" => ::std::option::Option::Some(BusinessCase::PERMIT_BIZ_CONTENT),
            "JOIN_DIRECT_BIZ_CONTENT" => ::std::option::Option::Some(BusinessCase::JOIN_DIRECT_BIZ_CONTENT),
            "KICK_OUT_BIZ_CONTENT" => ::std::option::Option::Some(BusinessCase::KICK_OUT_BIZ_CONTENT),
            "LIST_CHANGE_BIZ_CONTENT" => ::std::option::Option::Some(BusinessCase::LIST_CHANGE_BIZ_CONTENT),
            "MULTI_LIVE_CONTENT" => ::std::option::Option::Some(BusinessCase::MULTI_LIVE_CONTENT),
            "COHOST_CONTENT" => ::std::option::Option::Some(BusinessCase::COHOST_CONTENT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [BusinessCase] = &[
        BusinessCase::BUSINESS_NOT_SET,
        BusinessCase::APPLY_BIZ_CONTENT,
        BusinessCase::INVITE_BIZ_CONTENT,
        BusinessCase::REPLY_BIZ_CONTENT,
        BusinessCase::PERMIT_BIZ_CONTENT,
        BusinessCase::JOIN_DIRECT_BIZ_CONTENT,
        BusinessCase::KICK_OUT_BIZ_CONTENT,
        BusinessCase::LIST_CHANGE_BIZ_CONTENT,
        BusinessCase::MULTI_LIVE_CONTENT,
        BusinessCase::COHOST_CONTENT,
    ];
}

impl ::protobuf::EnumFull for BusinessCase {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("BusinessCase").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            BusinessCase::BUSINESS_NOT_SET => 0,
            BusinessCase::APPLY_BIZ_CONTENT => 1,
            BusinessCase::INVITE_BIZ_CONTENT => 2,
            BusinessCase::REPLY_BIZ_CONTENT => 3,
            BusinessCase::PERMIT_BIZ_CONTENT => 4,
            BusinessCase::JOIN_DIRECT_BIZ_CONTENT => 5,
            BusinessCase::KICK_OUT_BIZ_CONTENT => 6,
            BusinessCase::LIST_CHANGE_BIZ_CONTENT => 7,
            BusinessCase::MULTI_LIVE_CONTENT => 8,
            BusinessCase::COHOST_CONTENT => 9,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for BusinessCase {
    fn default() -> Self {
        BusinessCase::BUSINESS_NOT_SET
    }
}

impl BusinessCase {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BusinessCase>("BusinessCase")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TikTok.ReplyStatus)
pub enum ReplyStatus {
    // @@protoc_insertion_point(enum_value:TikTok.ReplyStatus.REPLY_STATUS_UNKNOWN)
    REPLY_STATUS_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:TikTok.ReplyStatus.REPLY_STATUS_AGREE)
    REPLY_STATUS_AGREE = 1,
    // @@protoc_insertion_point(enum_value:TikTok.ReplyStatus.REPLY_STATUS_REFUSE_PERSONALLY)
    REPLY_STATUS_REFUSE_PERSONALLY = 2,
    // @@protoc_insertion_point(enum_value:TikTok.ReplyStatus.REPLY_STATUS_REFUSE_TYPE_NOT_SUPPORT)
    REPLY_STATUS_REFUSE_TYPE_NOT_SUPPORT = 3,
    // @@protoc_insertion_point(enum_value:TikTok.ReplyStatus.REPLY_STATUS_REFUSE_PROCESSING_INVITATION)
    REPLY_STATUS_REFUSE_PROCESSING_INVITATION = 4,
    // @@protoc_insertion_point(enum_value:TikTok.ReplyStatus.REPLY_STATUS_REFUSE_BY_TIMEOUT)
    REPLY_STATUS_REFUSE_BY_TIMEOUT = 5,
    // @@protoc_insertion_point(enum_value:TikTok.ReplyStatus.REPLY_STATUS_REFUSE_EXCEPTION)
    REPLY_STATUS_REFUSE_EXCEPTION = 6,
    // @@protoc_insertion_point(enum_value:TikTok.ReplyStatus.REPLY_STATUS_REFUSE_SYSTEM_NOT_SUPPORTED)
    REPLY_STATUS_REFUSE_SYSTEM_NOT_SUPPORTED = 7,
    // @@protoc_insertion_point(enum_value:TikTok.ReplyStatus.REPLY_STATUS_REFUSE_SUBTYPE_DIFFERENCE)
    REPLY_STATUS_REFUSE_SUBTYPE_DIFFERENCE = 8,
    // @@protoc_insertion_point(enum_value:TikTok.ReplyStatus.REPLY_STATUS_REFUSE_IN_MICROOM)
    REPLY_STATUS_REFUSE_IN_MICROOM = 9,
    // @@protoc_insertion_point(enum_value:TikTok.ReplyStatus.REPLY_STATUS_REFUSE_NOT_LOAD_PLUGIN)
    REPLY_STATUS_REFUSE_NOT_LOAD_PLUGIN = 10,
    // @@protoc_insertion_point(enum_value:TikTok.ReplyStatus.REPLY_STATUS_REFUSE_IN_MULTI_GUEST)
    REPLY_STATUS_REFUSE_IN_MULTI_GUEST = 11,
    // @@protoc_insertion_point(enum_value:TikTok.ReplyStatus.REPLY_STATUS_REFUSE_PAUSE_LIVE)
    REPLY_STATUS_REFUSE_PAUSE_LIVE = 12,
    // @@protoc_insertion_point(enum_value:TikTok.ReplyStatus.REPLY_STATUS_REFUSE_OPEN_CAMERA_DIALOG_SHOWING)
    REPLY_STATUS_REFUSE_OPEN_CAMERA_DIALOG_SHOWING = 13,
    // @@protoc_insertion_point(enum_value:TikTok.ReplyStatus.REPLY_STATUS_REFUSE_DRAW_GUESSING)
    REPLY_STATUS_REFUSE_DRAW_GUESSING = 14,
    // @@protoc_insertion_point(enum_value:TikTok.ReplyStatus.REPLY_STATUS_REFUSE_RANDOM_MATCHING)
    REPLY_STATUS_REFUSE_RANDOM_MATCHING = 15,
    // @@protoc_insertion_point(enum_value:TikTok.ReplyStatus.REPLY_STATUS_REFUSE_IN_MATCH_PROCESSING)
    REPLY_STATUS_REFUSE_IN_MATCH_PROCESSING = 16,
    // @@protoc_insertion_point(enum_value:TikTok.ReplyStatus.REPLY_STATUS_REFUSE_IN_MICROOM_FOR_MULTI_COHOST)
    REPLY_STATUS_REFUSE_IN_MICROOM_FOR_MULTI_COHOST = 17,
    // @@protoc_insertion_point(enum_value:TikTok.ReplyStatus.REPLY_STATUS_REFUSE_COHOST_FINISHED)
    REPLY_STATUS_REFUSE_COHOST_FINISHED = 18,
    // @@protoc_insertion_point(enum_value:TikTok.ReplyStatus.REPLY_STATUS_REFUSE_NOT_CONNECTED)
    REPLY_STATUS_REFUSE_NOT_CONNECTED = 19,
    // @@protoc_insertion_point(enum_value:TikTok.ReplyStatus.REPLY_STATUS_REFUSE_LINKMIC_FULL)
    REPLY_STATUS_REFUSE_LINKMIC_FULL = 20,
    // @@protoc_insertion_point(enum_value:TikTok.ReplyStatus.REPLY_STATUS_REFUSE_ARC_INCOMPATIBLE)
    REPLY_STATUS_REFUSE_ARC_INCOMPATIBLE = 21,
    // @@protoc_insertion_point(enum_value:TikTok.ReplyStatus.REPLY_STATUS_REFUSE_PROCESSING_OTHER_INVITE)
    REPLY_STATUS_REFUSE_PROCESSING_OTHER_INVITE = 22,
    // @@protoc_insertion_point(enum_value:TikTok.ReplyStatus.REPLY_STATUS_REFUSE_PROCESSING_OTHER_APPLY)
    REPLY_STATUS_REFUSE_PROCESSING_OTHER_APPLY = 23,
    // @@protoc_insertion_point(enum_value:TikTok.ReplyStatus.REPLY_STATUS_REFUSE_IN_ANCHOR_COHOST)
    REPLY_STATUS_REFUSE_IN_ANCHOR_COHOST = 24,
    // @@protoc_insertion_point(enum_value:TikTok.ReplyStatus.REPLY_STATUS_REFUSE_TOPIC_PAIRING)
    REPLY_STATUS_REFUSE_TOPIC_PAIRING = 25,
}

impl ::protobuf::Enum for ReplyStatus {
    const NAME: &'static str = "ReplyStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ReplyStatus> {
        match value {
            0 => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_UNKNOWN),
            1 => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_AGREE),
            2 => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_PERSONALLY),
            3 => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_TYPE_NOT_SUPPORT),
            4 => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_PROCESSING_INVITATION),
            5 => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_BY_TIMEOUT),
            6 => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_EXCEPTION),
            7 => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_SYSTEM_NOT_SUPPORTED),
            8 => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_SUBTYPE_DIFFERENCE),
            9 => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_IN_MICROOM),
            10 => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_NOT_LOAD_PLUGIN),
            11 => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_IN_MULTI_GUEST),
            12 => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_PAUSE_LIVE),
            13 => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_OPEN_CAMERA_DIALOG_SHOWING),
            14 => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_DRAW_GUESSING),
            15 => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_RANDOM_MATCHING),
            16 => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_IN_MATCH_PROCESSING),
            17 => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_IN_MICROOM_FOR_MULTI_COHOST),
            18 => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_COHOST_FINISHED),
            19 => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_NOT_CONNECTED),
            20 => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_LINKMIC_FULL),
            21 => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_ARC_INCOMPATIBLE),
            22 => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_PROCESSING_OTHER_INVITE),
            23 => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_PROCESSING_OTHER_APPLY),
            24 => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_IN_ANCHOR_COHOST),
            25 => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_TOPIC_PAIRING),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ReplyStatus> {
        match str {
            "REPLY_STATUS_UNKNOWN" => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_UNKNOWN),
            "REPLY_STATUS_AGREE" => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_AGREE),
            "REPLY_STATUS_REFUSE_PERSONALLY" => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_PERSONALLY),
            "REPLY_STATUS_REFUSE_TYPE_NOT_SUPPORT" => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_TYPE_NOT_SUPPORT),
            "REPLY_STATUS_REFUSE_PROCESSING_INVITATION" => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_PROCESSING_INVITATION),
            "REPLY_STATUS_REFUSE_BY_TIMEOUT" => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_BY_TIMEOUT),
            "REPLY_STATUS_REFUSE_EXCEPTION" => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_EXCEPTION),
            "REPLY_STATUS_REFUSE_SYSTEM_NOT_SUPPORTED" => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_SYSTEM_NOT_SUPPORTED),
            "REPLY_STATUS_REFUSE_SUBTYPE_DIFFERENCE" => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_SUBTYPE_DIFFERENCE),
            "REPLY_STATUS_REFUSE_IN_MICROOM" => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_IN_MICROOM),
            "REPLY_STATUS_REFUSE_NOT_LOAD_PLUGIN" => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_NOT_LOAD_PLUGIN),
            "REPLY_STATUS_REFUSE_IN_MULTI_GUEST" => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_IN_MULTI_GUEST),
            "REPLY_STATUS_REFUSE_PAUSE_LIVE" => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_PAUSE_LIVE),
            "REPLY_STATUS_REFUSE_OPEN_CAMERA_DIALOG_SHOWING" => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_OPEN_CAMERA_DIALOG_SHOWING),
            "REPLY_STATUS_REFUSE_DRAW_GUESSING" => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_DRAW_GUESSING),
            "REPLY_STATUS_REFUSE_RANDOM_MATCHING" => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_RANDOM_MATCHING),
            "REPLY_STATUS_REFUSE_IN_MATCH_PROCESSING" => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_IN_MATCH_PROCESSING),
            "REPLY_STATUS_REFUSE_IN_MICROOM_FOR_MULTI_COHOST" => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_IN_MICROOM_FOR_MULTI_COHOST),
            "REPLY_STATUS_REFUSE_COHOST_FINISHED" => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_COHOST_FINISHED),
            "REPLY_STATUS_REFUSE_NOT_CONNECTED" => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_NOT_CONNECTED),
            "REPLY_STATUS_REFUSE_LINKMIC_FULL" => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_LINKMIC_FULL),
            "REPLY_STATUS_REFUSE_ARC_INCOMPATIBLE" => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_ARC_INCOMPATIBLE),
            "REPLY_STATUS_REFUSE_PROCESSING_OTHER_INVITE" => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_PROCESSING_OTHER_INVITE),
            "REPLY_STATUS_REFUSE_PROCESSING_OTHER_APPLY" => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_PROCESSING_OTHER_APPLY),
            "REPLY_STATUS_REFUSE_IN_ANCHOR_COHOST" => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_IN_ANCHOR_COHOST),
            "REPLY_STATUS_REFUSE_TOPIC_PAIRING" => ::std::option::Option::Some(ReplyStatus::REPLY_STATUS_REFUSE_TOPIC_PAIRING),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ReplyStatus] = &[
        ReplyStatus::REPLY_STATUS_UNKNOWN,
        ReplyStatus::REPLY_STATUS_AGREE,
        ReplyStatus::REPLY_STATUS_REFUSE_PERSONALLY,
        ReplyStatus::REPLY_STATUS_REFUSE_TYPE_NOT_SUPPORT,
        ReplyStatus::REPLY_STATUS_REFUSE_PROCESSING_INVITATION,
        ReplyStatus::REPLY_STATUS_REFUSE_BY_TIMEOUT,
        ReplyStatus::REPLY_STATUS_REFUSE_EXCEPTION,
        ReplyStatus::REPLY_STATUS_REFUSE_SYSTEM_NOT_SUPPORTED,
        ReplyStatus::REPLY_STATUS_REFUSE_SUBTYPE_DIFFERENCE,
        ReplyStatus::REPLY_STATUS_REFUSE_IN_MICROOM,
        ReplyStatus::REPLY_STATUS_REFUSE_NOT_LOAD_PLUGIN,
        ReplyStatus::REPLY_STATUS_REFUSE_IN_MULTI_GUEST,
        ReplyStatus::REPLY_STATUS_REFUSE_PAUSE_LIVE,
        ReplyStatus::REPLY_STATUS_REFUSE_OPEN_CAMERA_DIALOG_SHOWING,
        ReplyStatus::REPLY_STATUS_REFUSE_DRAW_GUESSING,
        ReplyStatus::REPLY_STATUS_REFUSE_RANDOM_MATCHING,
        ReplyStatus::REPLY_STATUS_REFUSE_IN_MATCH_PROCESSING,
        ReplyStatus::REPLY_STATUS_REFUSE_IN_MICROOM_FOR_MULTI_COHOST,
        ReplyStatus::REPLY_STATUS_REFUSE_COHOST_FINISHED,
        ReplyStatus::REPLY_STATUS_REFUSE_NOT_CONNECTED,
        ReplyStatus::REPLY_STATUS_REFUSE_LINKMIC_FULL,
        ReplyStatus::REPLY_STATUS_REFUSE_ARC_INCOMPATIBLE,
        ReplyStatus::REPLY_STATUS_REFUSE_PROCESSING_OTHER_INVITE,
        ReplyStatus::REPLY_STATUS_REFUSE_PROCESSING_OTHER_APPLY,
        ReplyStatus::REPLY_STATUS_REFUSE_IN_ANCHOR_COHOST,
        ReplyStatus::REPLY_STATUS_REFUSE_TOPIC_PAIRING,
    ];
}

impl ::protobuf::EnumFull for ReplyStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ReplyStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ReplyStatus {
    fn default() -> Self {
        ReplyStatus::REPLY_STATUS_UNKNOWN
    }
}

impl ReplyStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ReplyStatus>("ReplyStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TikTok.SubscribeType)
pub enum SubscribeType {
    // @@protoc_insertion_point(enum_value:TikTok.SubscribeType.SUBSCRIBETYPE_ONCE)
    SUBSCRIBETYPE_ONCE = 0,
    // @@protoc_insertion_point(enum_value:TikTok.SubscribeType.SUBSCRIBETYPE_AUTO)
    SUBSCRIBETYPE_AUTO = 1,
    // @@protoc_insertion_point(enum_value:TikTok.SubscribeType.SUBSCRIBETYPE_DEFAULT)
    SUBSCRIBETYPE_DEFAULT = 100,
}

impl ::protobuf::Enum for SubscribeType {
    const NAME: &'static str = "SubscribeType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SubscribeType> {
        match value {
            0 => ::std::option::Option::Some(SubscribeType::SUBSCRIBETYPE_ONCE),
            1 => ::std::option::Option::Some(SubscribeType::SUBSCRIBETYPE_AUTO),
            100 => ::std::option::Option::Some(SubscribeType::SUBSCRIBETYPE_DEFAULT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SubscribeType> {
        match str {
            "SUBSCRIBETYPE_ONCE" => ::std::option::Option::Some(SubscribeType::SUBSCRIBETYPE_ONCE),
            "SUBSCRIBETYPE_AUTO" => ::std::option::Option::Some(SubscribeType::SUBSCRIBETYPE_AUTO),
            "SUBSCRIBETYPE_DEFAULT" => ::std::option::Option::Some(SubscribeType::SUBSCRIBETYPE_DEFAULT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SubscribeType] = &[
        SubscribeType::SUBSCRIBETYPE_ONCE,
        SubscribeType::SUBSCRIBETYPE_AUTO,
        SubscribeType::SUBSCRIBETYPE_DEFAULT,
    ];
}

impl ::protobuf::EnumFull for SubscribeType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SubscribeType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            SubscribeType::SUBSCRIBETYPE_ONCE => 0,
            SubscribeType::SUBSCRIBETYPE_AUTO => 1,
            SubscribeType::SUBSCRIBETYPE_DEFAULT => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SubscribeType {
    fn default() -> Self {
        SubscribeType::SUBSCRIBETYPE_ONCE
    }
}

impl SubscribeType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SubscribeType>("SubscribeType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TikTok.OldSubscribeStatus)
pub enum OldSubscribeStatus {
    // @@protoc_insertion_point(enum_value:TikTok.OldSubscribeStatus.OLDSUBSCRIBESTATUS_FIRST)
    OLDSUBSCRIBESTATUS_FIRST = 0,
    // @@protoc_insertion_point(enum_value:TikTok.OldSubscribeStatus.OLDSUBSCRIBESTATUS_RESUB)
    OLDSUBSCRIBESTATUS_RESUB = 1,
    // @@protoc_insertion_point(enum_value:TikTok.OldSubscribeStatus.OLDSUBSCRIBESTATUS_SUBINGRACEPERIOD)
    OLDSUBSCRIBESTATUS_SUBINGRACEPERIOD = 2,
    // @@protoc_insertion_point(enum_value:TikTok.OldSubscribeStatus.OLDSUBSCRIBESTATUS_SUBNOTINGRACEPERIOD)
    OLDSUBSCRIBESTATUS_SUBNOTINGRACEPERIOD = 3,
    // @@protoc_insertion_point(enum_value:TikTok.OldSubscribeStatus.OLDSUBSCRIBESTATUS_DEFAULT)
    OLDSUBSCRIBESTATUS_DEFAULT = 100,
}

impl ::protobuf::Enum for OldSubscribeStatus {
    const NAME: &'static str = "OldSubscribeStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OldSubscribeStatus> {
        match value {
            0 => ::std::option::Option::Some(OldSubscribeStatus::OLDSUBSCRIBESTATUS_FIRST),
            1 => ::std::option::Option::Some(OldSubscribeStatus::OLDSUBSCRIBESTATUS_RESUB),
            2 => ::std::option::Option::Some(OldSubscribeStatus::OLDSUBSCRIBESTATUS_SUBINGRACEPERIOD),
            3 => ::std::option::Option::Some(OldSubscribeStatus::OLDSUBSCRIBESTATUS_SUBNOTINGRACEPERIOD),
            100 => ::std::option::Option::Some(OldSubscribeStatus::OLDSUBSCRIBESTATUS_DEFAULT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<OldSubscribeStatus> {
        match str {
            "OLDSUBSCRIBESTATUS_FIRST" => ::std::option::Option::Some(OldSubscribeStatus::OLDSUBSCRIBESTATUS_FIRST),
            "OLDSUBSCRIBESTATUS_RESUB" => ::std::option::Option::Some(OldSubscribeStatus::OLDSUBSCRIBESTATUS_RESUB),
            "OLDSUBSCRIBESTATUS_SUBINGRACEPERIOD" => ::std::option::Option::Some(OldSubscribeStatus::OLDSUBSCRIBESTATUS_SUBINGRACEPERIOD),
            "OLDSUBSCRIBESTATUS_SUBNOTINGRACEPERIOD" => ::std::option::Option::Some(OldSubscribeStatus::OLDSUBSCRIBESTATUS_SUBNOTINGRACEPERIOD),
            "OLDSUBSCRIBESTATUS_DEFAULT" => ::std::option::Option::Some(OldSubscribeStatus::OLDSUBSCRIBESTATUS_DEFAULT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [OldSubscribeStatus] = &[
        OldSubscribeStatus::OLDSUBSCRIBESTATUS_FIRST,
        OldSubscribeStatus::OLDSUBSCRIBESTATUS_RESUB,
        OldSubscribeStatus::OLDSUBSCRIBESTATUS_SUBINGRACEPERIOD,
        OldSubscribeStatus::OLDSUBSCRIBESTATUS_SUBNOTINGRACEPERIOD,
        OldSubscribeStatus::OLDSUBSCRIBESTATUS_DEFAULT,
    ];
}

impl ::protobuf::EnumFull for OldSubscribeStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("OldSubscribeStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            OldSubscribeStatus::OLDSUBSCRIBESTATUS_FIRST => 0,
            OldSubscribeStatus::OLDSUBSCRIBESTATUS_RESUB => 1,
            OldSubscribeStatus::OLDSUBSCRIBESTATUS_SUBINGRACEPERIOD => 2,
            OldSubscribeStatus::OLDSUBSCRIBESTATUS_SUBNOTINGRACEPERIOD => 3,
            OldSubscribeStatus::OLDSUBSCRIBESTATUS_DEFAULT => 4,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for OldSubscribeStatus {
    fn default() -> Self {
        OldSubscribeStatus::OLDSUBSCRIBESTATUS_FIRST
    }
}

impl OldSubscribeStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<OldSubscribeStatus>("OldSubscribeStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TikTok.SubscribingStatus)
pub enum SubscribingStatus {
    // @@protoc_insertion_point(enum_value:TikTok.SubscribingStatus.SUBSCRIBINGSTATUS_UNKNOWN)
    SUBSCRIBINGSTATUS_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:TikTok.SubscribingStatus.SUBSCRIBINGSTATUS_ONCE)
    SUBSCRIBINGSTATUS_ONCE = 1,
    // @@protoc_insertion_point(enum_value:TikTok.SubscribingStatus.SUBSCRIBINGSTATUS_CIRCLE)
    SUBSCRIBINGSTATUS_CIRCLE = 2,
    // @@protoc_insertion_point(enum_value:TikTok.SubscribingStatus.SUBSCRIBINGSTATUS_CIRCLECANCEL)
    SUBSCRIBINGSTATUS_CIRCLECANCEL = 3,
    // @@protoc_insertion_point(enum_value:TikTok.SubscribingStatus.SUBSCRIBINGSTATUS_REFUND)
    SUBSCRIBINGSTATUS_REFUND = 4,
    // @@protoc_insertion_point(enum_value:TikTok.SubscribingStatus.SUBSCRIBINGSTATUS_INGRACEPERIOD)
    SUBSCRIBINGSTATUS_INGRACEPERIOD = 5,
    // @@protoc_insertion_point(enum_value:TikTok.SubscribingStatus.SUBSCRIBINGSTATUS_NOTINGRACEPERIOD)
    SUBSCRIBINGSTATUS_NOTINGRACEPERIOD = 6,
}

impl ::protobuf::Enum for SubscribingStatus {
    const NAME: &'static str = "SubscribingStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SubscribingStatus> {
        match value {
            0 => ::std::option::Option::Some(SubscribingStatus::SUBSCRIBINGSTATUS_UNKNOWN),
            1 => ::std::option::Option::Some(SubscribingStatus::SUBSCRIBINGSTATUS_ONCE),
            2 => ::std::option::Option::Some(SubscribingStatus::SUBSCRIBINGSTATUS_CIRCLE),
            3 => ::std::option::Option::Some(SubscribingStatus::SUBSCRIBINGSTATUS_CIRCLECANCEL),
            4 => ::std::option::Option::Some(SubscribingStatus::SUBSCRIBINGSTATUS_REFUND),
            5 => ::std::option::Option::Some(SubscribingStatus::SUBSCRIBINGSTATUS_INGRACEPERIOD),
            6 => ::std::option::Option::Some(SubscribingStatus::SUBSCRIBINGSTATUS_NOTINGRACEPERIOD),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SubscribingStatus> {
        match str {
            "SUBSCRIBINGSTATUS_UNKNOWN" => ::std::option::Option::Some(SubscribingStatus::SUBSCRIBINGSTATUS_UNKNOWN),
            "SUBSCRIBINGSTATUS_ONCE" => ::std::option::Option::Some(SubscribingStatus::SUBSCRIBINGSTATUS_ONCE),
            "SUBSCRIBINGSTATUS_CIRCLE" => ::std::option::Option::Some(SubscribingStatus::SUBSCRIBINGSTATUS_CIRCLE),
            "SUBSCRIBINGSTATUS_CIRCLECANCEL" => ::std::option::Option::Some(SubscribingStatus::SUBSCRIBINGSTATUS_CIRCLECANCEL),
            "SUBSCRIBINGSTATUS_REFUND" => ::std::option::Option::Some(SubscribingStatus::SUBSCRIBINGSTATUS_REFUND),
            "SUBSCRIBINGSTATUS_INGRACEPERIOD" => ::std::option::Option::Some(SubscribingStatus::SUBSCRIBINGSTATUS_INGRACEPERIOD),
            "SUBSCRIBINGSTATUS_NOTINGRACEPERIOD" => ::std::option::Option::Some(SubscribingStatus::SUBSCRIBINGSTATUS_NOTINGRACEPERIOD),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SubscribingStatus] = &[
        SubscribingStatus::SUBSCRIBINGSTATUS_UNKNOWN,
        SubscribingStatus::SUBSCRIBINGSTATUS_ONCE,
        SubscribingStatus::SUBSCRIBINGSTATUS_CIRCLE,
        SubscribingStatus::SUBSCRIBINGSTATUS_CIRCLECANCEL,
        SubscribingStatus::SUBSCRIBINGSTATUS_REFUND,
        SubscribingStatus::SUBSCRIBINGSTATUS_INGRACEPERIOD,
        SubscribingStatus::SUBSCRIBINGSTATUS_NOTINGRACEPERIOD,
    ];
}

impl ::protobuf::EnumFull for SubscribingStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SubscribingStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SubscribingStatus {
    fn default() -> Self {
        SubscribingStatus::SUBSCRIBINGSTATUS_UNKNOWN
    }
}

impl SubscribingStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SubscribingStatus>("SubscribingStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TikTok.LinkmicStatus)
pub enum LinkmicStatus {
    // @@protoc_insertion_point(enum_value:TikTok.LinkmicStatus.Disable)
    Disable = 0,
    // @@protoc_insertion_point(enum_value:TikTok.LinkmicStatus.Enable)
    Enable = 1,
    // @@protoc_insertion_point(enum_value:TikTok.LinkmicStatus.Just_Following)
    Just_Following = 2,
    // @@protoc_insertion_point(enum_value:TikTok.LinkmicStatus.Multi_Linking)
    Multi_Linking = 3,
    // @@protoc_insertion_point(enum_value:TikTok.LinkmicStatus.Multi_Linking_Only_Following)
    Multi_Linking_Only_Following = 4,
}

impl ::protobuf::Enum for LinkmicStatus {
    const NAME: &'static str = "LinkmicStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LinkmicStatus> {
        match value {
            0 => ::std::option::Option::Some(LinkmicStatus::Disable),
            1 => ::std::option::Option::Some(LinkmicStatus::Enable),
            2 => ::std::option::Option::Some(LinkmicStatus::Just_Following),
            3 => ::std::option::Option::Some(LinkmicStatus::Multi_Linking),
            4 => ::std::option::Option::Some(LinkmicStatus::Multi_Linking_Only_Following),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<LinkmicStatus> {
        match str {
            "Disable" => ::std::option::Option::Some(LinkmicStatus::Disable),
            "Enable" => ::std::option::Option::Some(LinkmicStatus::Enable),
            "Just_Following" => ::std::option::Option::Some(LinkmicStatus::Just_Following),
            "Multi_Linking" => ::std::option::Option::Some(LinkmicStatus::Multi_Linking),
            "Multi_Linking_Only_Following" => ::std::option::Option::Some(LinkmicStatus::Multi_Linking_Only_Following),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LinkmicStatus] = &[
        LinkmicStatus::Disable,
        LinkmicStatus::Enable,
        LinkmicStatus::Just_Following,
        LinkmicStatus::Multi_Linking,
        LinkmicStatus::Multi_Linking_Only_Following,
    ];
}

impl ::protobuf::EnumFull for LinkmicStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("LinkmicStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for LinkmicStatus {
    fn default() -> Self {
        LinkmicStatus::Disable
    }
}

impl LinkmicStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LinkmicStatus>("LinkmicStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TikTok.MemberMessageAction)
pub enum MemberMessageAction {
    // @@protoc_insertion_point(enum_value:TikTok.MemberMessageAction.UNKNOWN)
    UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:TikTok.MemberMessageAction.JOINED)
    JOINED = 1,
    // @@protoc_insertion_point(enum_value:TikTok.MemberMessageAction.SUBSCRIBED)
    SUBSCRIBED = 3,
}

impl ::protobuf::Enum for MemberMessageAction {
    const NAME: &'static str = "MemberMessageAction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MemberMessageAction> {
        match value {
            0 => ::std::option::Option::Some(MemberMessageAction::UNKNOWN),
            1 => ::std::option::Option::Some(MemberMessageAction::JOINED),
            3 => ::std::option::Option::Some(MemberMessageAction::SUBSCRIBED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<MemberMessageAction> {
        match str {
            "UNKNOWN" => ::std::option::Option::Some(MemberMessageAction::UNKNOWN),
            "JOINED" => ::std::option::Option::Some(MemberMessageAction::JOINED),
            "SUBSCRIBED" => ::std::option::Option::Some(MemberMessageAction::SUBSCRIBED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MemberMessageAction] = &[
        MemberMessageAction::UNKNOWN,
        MemberMessageAction::JOINED,
        MemberMessageAction::SUBSCRIBED,
    ];
}

impl ::protobuf::EnumFull for MemberMessageAction {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MemberMessageAction").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            MemberMessageAction::UNKNOWN => 0,
            MemberMessageAction::JOINED => 1,
            MemberMessageAction::SUBSCRIBED => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MemberMessageAction {
    fn default() -> Self {
        MemberMessageAction::UNKNOWN
    }
}

impl MemberMessageAction {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MemberMessageAction>("MemberMessageAction")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TikTok.ControlAction)
pub enum ControlAction {
    // @@protoc_insertion_point(enum_value:TikTok.ControlAction.ControlActionUNKNOWN)
    ControlActionUNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:TikTok.ControlAction.STREAM_PAUSED)
    STREAM_PAUSED = 1,
    // @@protoc_insertion_point(enum_value:TikTok.ControlAction.STREAM_UNPAUSED)
    STREAM_UNPAUSED = 2,
    // @@protoc_insertion_point(enum_value:TikTok.ControlAction.STREAM_ENDED)
    STREAM_ENDED = 3,
}

impl ::protobuf::Enum for ControlAction {
    const NAME: &'static str = "ControlAction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ControlAction> {
        match value {
            0 => ::std::option::Option::Some(ControlAction::ControlActionUNKNOWN),
            1 => ::std::option::Option::Some(ControlAction::STREAM_PAUSED),
            2 => ::std::option::Option::Some(ControlAction::STREAM_UNPAUSED),
            3 => ::std::option::Option::Some(ControlAction::STREAM_ENDED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ControlAction> {
        match str {
            "ControlActionUNKNOWN" => ::std::option::Option::Some(ControlAction::ControlActionUNKNOWN),
            "STREAM_PAUSED" => ::std::option::Option::Some(ControlAction::STREAM_PAUSED),
            "STREAM_UNPAUSED" => ::std::option::Option::Some(ControlAction::STREAM_UNPAUSED),
            "STREAM_ENDED" => ::std::option::Option::Some(ControlAction::STREAM_ENDED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ControlAction] = &[
        ControlAction::ControlActionUNKNOWN,
        ControlAction::STREAM_PAUSED,
        ControlAction::STREAM_UNPAUSED,
        ControlAction::STREAM_ENDED,
    ];
}

impl ::protobuf::EnumFull for ControlAction {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ControlAction").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ControlAction {
    fn default() -> Self {
        ControlAction::ControlActionUNKNOWN
    }
}

impl ControlAction {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ControlAction>("ControlAction")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TikTok.LinkLayerMessageType)
pub enum LinkLayerMessageType {
    // @@protoc_insertion_point(enum_value:TikTok.LinkLayerMessageType.Linker_Unknown)
    Linker_Unknown = 0,
    // @@protoc_insertion_point(enum_value:TikTok.LinkLayerMessageType.Linker_Create)
    Linker_Create = 1,
    // @@protoc_insertion_point(enum_value:TikTok.LinkLayerMessageType.Linker_Invite)
    Linker_Invite = 2,
    // @@protoc_insertion_point(enum_value:TikTok.LinkLayerMessageType.Linker_Apply)
    Linker_Apply = 3,
    // @@protoc_insertion_point(enum_value:TikTok.LinkLayerMessageType.Linker_Permit)
    Linker_Permit = 4,
    // @@protoc_insertion_point(enum_value:TikTok.LinkLayerMessageType.Linker_Reply)
    Linker_Reply = 5,
    // @@protoc_insertion_point(enum_value:TikTok.LinkLayerMessageType.Linker_Kick_Out)
    Linker_Kick_Out = 6,
    // @@protoc_insertion_point(enum_value:TikTok.LinkLayerMessageType.Linker_Cancel_Apply)
    Linker_Cancel_Apply = 7,
    // @@protoc_insertion_point(enum_value:TikTok.LinkLayerMessageType.Linker_Cancel_Invite)
    Linker_Cancel_Invite = 8,
    // @@protoc_insertion_point(enum_value:TikTok.LinkLayerMessageType.Linker_Leave)
    Linker_Leave = 9,
    // @@protoc_insertion_point(enum_value:TikTok.LinkLayerMessageType.Linker_Finish)
    Linker_Finish = 10,
    // @@protoc_insertion_point(enum_value:TikTok.LinkLayerMessageType.Linker_List_Change)
    Linker_List_Change = 11,
    // @@protoc_insertion_point(enum_value:TikTok.LinkLayerMessageType.Linker_Join_Direct)
    Linker_Join_Direct = 12,
    // @@protoc_insertion_point(enum_value:TikTok.LinkLayerMessageType.Linker_Join_Group)
    Linker_Join_Group = 13,
    // @@protoc_insertion_point(enum_value:TikTok.LinkLayerMessageType.Linker_Permit_Group)
    Linker_Permit_Group = 14,
    // @@protoc_insertion_point(enum_value:TikTok.LinkLayerMessageType.Linker_Cancel_Group)
    Linker_Cancel_Group = 15,
    // @@protoc_insertion_point(enum_value:TikTok.LinkLayerMessageType.Linker_Leave_Group)
    Linker_Leave_Group = 16,
    // @@protoc_insertion_point(enum_value:TikTok.LinkLayerMessageType.Linker_P2P_Group_Change)
    Linker_P2P_Group_Change = 17,
    // @@protoc_insertion_point(enum_value:TikTok.LinkLayerMessageType.Linker_Group_Change)
    Linker_Group_Change = 18,
}

impl ::protobuf::Enum for LinkLayerMessageType {
    const NAME: &'static str = "LinkLayerMessageType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LinkLayerMessageType> {
        match value {
            0 => ::std::option::Option::Some(LinkLayerMessageType::Linker_Unknown),
            1 => ::std::option::Option::Some(LinkLayerMessageType::Linker_Create),
            2 => ::std::option::Option::Some(LinkLayerMessageType::Linker_Invite),
            3 => ::std::option::Option::Some(LinkLayerMessageType::Linker_Apply),
            4 => ::std::option::Option::Some(LinkLayerMessageType::Linker_Permit),
            5 => ::std::option::Option::Some(LinkLayerMessageType::Linker_Reply),
            6 => ::std::option::Option::Some(LinkLayerMessageType::Linker_Kick_Out),
            7 => ::std::option::Option::Some(LinkLayerMessageType::Linker_Cancel_Apply),
            8 => ::std::option::Option::Some(LinkLayerMessageType::Linker_Cancel_Invite),
            9 => ::std::option::Option::Some(LinkLayerMessageType::Linker_Leave),
            10 => ::std::option::Option::Some(LinkLayerMessageType::Linker_Finish),
            11 => ::std::option::Option::Some(LinkLayerMessageType::Linker_List_Change),
            12 => ::std::option::Option::Some(LinkLayerMessageType::Linker_Join_Direct),
            13 => ::std::option::Option::Some(LinkLayerMessageType::Linker_Join_Group),
            14 => ::std::option::Option::Some(LinkLayerMessageType::Linker_Permit_Group),
            15 => ::std::option::Option::Some(LinkLayerMessageType::Linker_Cancel_Group),
            16 => ::std::option::Option::Some(LinkLayerMessageType::Linker_Leave_Group),
            17 => ::std::option::Option::Some(LinkLayerMessageType::Linker_P2P_Group_Change),
            18 => ::std::option::Option::Some(LinkLayerMessageType::Linker_Group_Change),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<LinkLayerMessageType> {
        match str {
            "Linker_Unknown" => ::std::option::Option::Some(LinkLayerMessageType::Linker_Unknown),
            "Linker_Create" => ::std::option::Option::Some(LinkLayerMessageType::Linker_Create),
            "Linker_Invite" => ::std::option::Option::Some(LinkLayerMessageType::Linker_Invite),
            "Linker_Apply" => ::std::option::Option::Some(LinkLayerMessageType::Linker_Apply),
            "Linker_Permit" => ::std::option::Option::Some(LinkLayerMessageType::Linker_Permit),
            "Linker_Reply" => ::std::option::Option::Some(LinkLayerMessageType::Linker_Reply),
            "Linker_Kick_Out" => ::std::option::Option::Some(LinkLayerMessageType::Linker_Kick_Out),
            "Linker_Cancel_Apply" => ::std::option::Option::Some(LinkLayerMessageType::Linker_Cancel_Apply),
            "Linker_Cancel_Invite" => ::std::option::Option::Some(LinkLayerMessageType::Linker_Cancel_Invite),
            "Linker_Leave" => ::std::option::Option::Some(LinkLayerMessageType::Linker_Leave),
            "Linker_Finish" => ::std::option::Option::Some(LinkLayerMessageType::Linker_Finish),
            "Linker_List_Change" => ::std::option::Option::Some(LinkLayerMessageType::Linker_List_Change),
            "Linker_Join_Direct" => ::std::option::Option::Some(LinkLayerMessageType::Linker_Join_Direct),
            "Linker_Join_Group" => ::std::option::Option::Some(LinkLayerMessageType::Linker_Join_Group),
            "Linker_Permit_Group" => ::std::option::Option::Some(LinkLayerMessageType::Linker_Permit_Group),
            "Linker_Cancel_Group" => ::std::option::Option::Some(LinkLayerMessageType::Linker_Cancel_Group),
            "Linker_Leave_Group" => ::std::option::Option::Some(LinkLayerMessageType::Linker_Leave_Group),
            "Linker_P2P_Group_Change" => ::std::option::Option::Some(LinkLayerMessageType::Linker_P2P_Group_Change),
            "Linker_Group_Change" => ::std::option::Option::Some(LinkLayerMessageType::Linker_Group_Change),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LinkLayerMessageType] = &[
        LinkLayerMessageType::Linker_Unknown,
        LinkLayerMessageType::Linker_Create,
        LinkLayerMessageType::Linker_Invite,
        LinkLayerMessageType::Linker_Apply,
        LinkLayerMessageType::Linker_Permit,
        LinkLayerMessageType::Linker_Reply,
        LinkLayerMessageType::Linker_Kick_Out,
        LinkLayerMessageType::Linker_Cancel_Apply,
        LinkLayerMessageType::Linker_Cancel_Invite,
        LinkLayerMessageType::Linker_Leave,
        LinkLayerMessageType::Linker_Finish,
        LinkLayerMessageType::Linker_List_Change,
        LinkLayerMessageType::Linker_Join_Direct,
        LinkLayerMessageType::Linker_Join_Group,
        LinkLayerMessageType::Linker_Permit_Group,
        LinkLayerMessageType::Linker_Cancel_Group,
        LinkLayerMessageType::Linker_Leave_Group,
        LinkLayerMessageType::Linker_P2P_Group_Change,
        LinkLayerMessageType::Linker_Group_Change,
    ];
}

impl ::protobuf::EnumFull for LinkLayerMessageType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("LinkLayerMessageType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for LinkLayerMessageType {
    fn default() -> Self {
        LinkLayerMessageType::Linker_Unknown
    }
}

impl LinkLayerMessageType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LinkLayerMessageType>("LinkLayerMessageType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TikTok.BarrageType)
pub enum BarrageType {
    // @@protoc_insertion_point(enum_value:TikTok.BarrageType.BarrageType_Unknown)
    BarrageType_Unknown = 0,
    // @@protoc_insertion_point(enum_value:TikTok.BarrageType.EComOrdering)
    EComOrdering = 1,
    // @@protoc_insertion_point(enum_value:TikTok.BarrageType.EComBuying)
    EComBuying = 2,
    // @@protoc_insertion_point(enum_value:TikTok.BarrageType.Normal)
    Normal = 3,
    // @@protoc_insertion_point(enum_value:TikTok.BarrageType.Subscribe)
    Subscribe = 4,
    // @@protoc_insertion_point(enum_value:TikTok.BarrageType.EventView)
    EventView = 5,
    // @@protoc_insertion_point(enum_value:TikTok.BarrageType.EventRegistered)
    EventRegistered = 6,
    // @@protoc_insertion_point(enum_value:TikTok.BarrageType.SubscribeGift)
    SubscribeGift = 7,
    // @@protoc_insertion_point(enum_value:TikTok.BarrageType.UserUpgrade)
    UserUpgrade = 8,
    // @@protoc_insertion_point(enum_value:TikTok.BarrageType.GradeUserEntranceNotification)
    GradeUserEntranceNotification = 9,
    // @@protoc_insertion_point(enum_value:TikTok.BarrageType.FansLevelUpgrade)
    FansLevelUpgrade = 10,
    // @@protoc_insertion_point(enum_value:TikTok.BarrageType.FansLevelEntrance)
    FansLevelEntrance = 11,
    // @@protoc_insertion_point(enum_value:TikTok.BarrageType.GamePartnership)
    GamePartnership = 12,
}

impl ::protobuf::Enum for BarrageType {
    const NAME: &'static str = "BarrageType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BarrageType> {
        match value {
            0 => ::std::option::Option::Some(BarrageType::BarrageType_Unknown),
            1 => ::std::option::Option::Some(BarrageType::EComOrdering),
            2 => ::std::option::Option::Some(BarrageType::EComBuying),
            3 => ::std::option::Option::Some(BarrageType::Normal),
            4 => ::std::option::Option::Some(BarrageType::Subscribe),
            5 => ::std::option::Option::Some(BarrageType::EventView),
            6 => ::std::option::Option::Some(BarrageType::EventRegistered),
            7 => ::std::option::Option::Some(BarrageType::SubscribeGift),
            8 => ::std::option::Option::Some(BarrageType::UserUpgrade),
            9 => ::std::option::Option::Some(BarrageType::GradeUserEntranceNotification),
            10 => ::std::option::Option::Some(BarrageType::FansLevelUpgrade),
            11 => ::std::option::Option::Some(BarrageType::FansLevelEntrance),
            12 => ::std::option::Option::Some(BarrageType::GamePartnership),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<BarrageType> {
        match str {
            "BarrageType_Unknown" => ::std::option::Option::Some(BarrageType::BarrageType_Unknown),
            "EComOrdering" => ::std::option::Option::Some(BarrageType::EComOrdering),
            "EComBuying" => ::std::option::Option::Some(BarrageType::EComBuying),
            "Normal" => ::std::option::Option::Some(BarrageType::Normal),
            "Subscribe" => ::std::option::Option::Some(BarrageType::Subscribe),
            "EventView" => ::std::option::Option::Some(BarrageType::EventView),
            "EventRegistered" => ::std::option::Option::Some(BarrageType::EventRegistered),
            "SubscribeGift" => ::std::option::Option::Some(BarrageType::SubscribeGift),
            "UserUpgrade" => ::std::option::Option::Some(BarrageType::UserUpgrade),
            "GradeUserEntranceNotification" => ::std::option::Option::Some(BarrageType::GradeUserEntranceNotification),
            "FansLevelUpgrade" => ::std::option::Option::Some(BarrageType::FansLevelUpgrade),
            "FansLevelEntrance" => ::std::option::Option::Some(BarrageType::FansLevelEntrance),
            "GamePartnership" => ::std::option::Option::Some(BarrageType::GamePartnership),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [BarrageType] = &[
        BarrageType::BarrageType_Unknown,
        BarrageType::EComOrdering,
        BarrageType::EComBuying,
        BarrageType::Normal,
        BarrageType::Subscribe,
        BarrageType::EventView,
        BarrageType::EventRegistered,
        BarrageType::SubscribeGift,
        BarrageType::UserUpgrade,
        BarrageType::GradeUserEntranceNotification,
        BarrageType::FansLevelUpgrade,
        BarrageType::FansLevelEntrance,
        BarrageType::GamePartnership,
    ];
}

impl ::protobuf::EnumFull for BarrageType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("BarrageType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for BarrageType {
    fn default() -> Self {
        BarrageType::BarrageType_Unknown
    }
}

impl BarrageType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BarrageType>("BarrageType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TikTok.EnvelopeBusinessType)
pub enum EnvelopeBusinessType {
    // @@protoc_insertion_point(enum_value:TikTok.EnvelopeBusinessType.BusinessTypeUnknown)
    BusinessTypeUnknown = 0,
    // @@protoc_insertion_point(enum_value:TikTok.EnvelopeBusinessType.BusinessTypeUserDiamond)
    BusinessTypeUserDiamond = 1,
    // @@protoc_insertion_point(enum_value:TikTok.EnvelopeBusinessType.BusinessTypePlatformDiamond)
    BusinessTypePlatformDiamond = 2,
    // @@protoc_insertion_point(enum_value:TikTok.EnvelopeBusinessType.BusinessTypePlatformShell)
    BusinessTypePlatformShell = 3,
    // @@protoc_insertion_point(enum_value:TikTok.EnvelopeBusinessType.BusinessTypePortal)
    BusinessTypePortal = 4,
    // @@protoc_insertion_point(enum_value:TikTok.EnvelopeBusinessType.BusinessTypePlatformMerch)
    BusinessTypePlatformMerch = 5,
    // @@protoc_insertion_point(enum_value:TikTok.EnvelopeBusinessType.BusinessTypeEoYDiamond)
    BusinessTypeEoYDiamond = 6,
    // @@protoc_insertion_point(enum_value:TikTok.EnvelopeBusinessType.BusinessTypeFanClubGtM)
    BusinessTypeFanClubGtM = 7,
}

impl ::protobuf::Enum for EnvelopeBusinessType {
    const NAME: &'static str = "EnvelopeBusinessType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EnvelopeBusinessType> {
        match value {
            0 => ::std::option::Option::Some(EnvelopeBusinessType::BusinessTypeUnknown),
            1 => ::std::option::Option::Some(EnvelopeBusinessType::BusinessTypeUserDiamond),
            2 => ::std::option::Option::Some(EnvelopeBusinessType::BusinessTypePlatformDiamond),
            3 => ::std::option::Option::Some(EnvelopeBusinessType::BusinessTypePlatformShell),
            4 => ::std::option::Option::Some(EnvelopeBusinessType::BusinessTypePortal),
            5 => ::std::option::Option::Some(EnvelopeBusinessType::BusinessTypePlatformMerch),
            6 => ::std::option::Option::Some(EnvelopeBusinessType::BusinessTypeEoYDiamond),
            7 => ::std::option::Option::Some(EnvelopeBusinessType::BusinessTypeFanClubGtM),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EnvelopeBusinessType> {
        match str {
            "BusinessTypeUnknown" => ::std::option::Option::Some(EnvelopeBusinessType::BusinessTypeUnknown),
            "BusinessTypeUserDiamond" => ::std::option::Option::Some(EnvelopeBusinessType::BusinessTypeUserDiamond),
            "BusinessTypePlatformDiamond" => ::std::option::Option::Some(EnvelopeBusinessType::BusinessTypePlatformDiamond),
            "BusinessTypePlatformShell" => ::std::option::Option::Some(EnvelopeBusinessType::BusinessTypePlatformShell),
            "BusinessTypePortal" => ::std::option::Option::Some(EnvelopeBusinessType::BusinessTypePortal),
            "BusinessTypePlatformMerch" => ::std::option::Option::Some(EnvelopeBusinessType::BusinessTypePlatformMerch),
            "BusinessTypeEoYDiamond" => ::std::option::Option::Some(EnvelopeBusinessType::BusinessTypeEoYDiamond),
            "BusinessTypeFanClubGtM" => ::std::option::Option::Some(EnvelopeBusinessType::BusinessTypeFanClubGtM),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EnvelopeBusinessType] = &[
        EnvelopeBusinessType::BusinessTypeUnknown,
        EnvelopeBusinessType::BusinessTypeUserDiamond,
        EnvelopeBusinessType::BusinessTypePlatformDiamond,
        EnvelopeBusinessType::BusinessTypePlatformShell,
        EnvelopeBusinessType::BusinessTypePortal,
        EnvelopeBusinessType::BusinessTypePlatformMerch,
        EnvelopeBusinessType::BusinessTypeEoYDiamond,
        EnvelopeBusinessType::BusinessTypeFanClubGtM,
    ];
}

impl ::protobuf::EnumFull for EnvelopeBusinessType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EnvelopeBusinessType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EnvelopeBusinessType {
    fn default() -> Self {
        EnvelopeBusinessType::BusinessTypeUnknown
    }
}

impl EnvelopeBusinessType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EnvelopeBusinessType>("EnvelopeBusinessType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TikTok.EnvelopeFollowShowStatus)
pub enum EnvelopeFollowShowStatus {
    // @@protoc_insertion_point(enum_value:TikTok.EnvelopeFollowShowStatus.EnvelopeFollowShowUnknown)
    EnvelopeFollowShowUnknown = 0,
    // @@protoc_insertion_point(enum_value:TikTok.EnvelopeFollowShowStatus.EnvelopeFollowShow)
    EnvelopeFollowShow = 1,
    // @@protoc_insertion_point(enum_value:TikTok.EnvelopeFollowShowStatus.EnvelopeFollowNotShow)
    EnvelopeFollowNotShow = 2,
}

impl ::protobuf::Enum for EnvelopeFollowShowStatus {
    const NAME: &'static str = "EnvelopeFollowShowStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EnvelopeFollowShowStatus> {
        match value {
            0 => ::std::option::Option::Some(EnvelopeFollowShowStatus::EnvelopeFollowShowUnknown),
            1 => ::std::option::Option::Some(EnvelopeFollowShowStatus::EnvelopeFollowShow),
            2 => ::std::option::Option::Some(EnvelopeFollowShowStatus::EnvelopeFollowNotShow),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EnvelopeFollowShowStatus> {
        match str {
            "EnvelopeFollowShowUnknown" => ::std::option::Option::Some(EnvelopeFollowShowStatus::EnvelopeFollowShowUnknown),
            "EnvelopeFollowShow" => ::std::option::Option::Some(EnvelopeFollowShowStatus::EnvelopeFollowShow),
            "EnvelopeFollowNotShow" => ::std::option::Option::Some(EnvelopeFollowShowStatus::EnvelopeFollowNotShow),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EnvelopeFollowShowStatus] = &[
        EnvelopeFollowShowStatus::EnvelopeFollowShowUnknown,
        EnvelopeFollowShowStatus::EnvelopeFollowShow,
        EnvelopeFollowShowStatus::EnvelopeFollowNotShow,
    ];
}

impl ::protobuf::EnumFull for EnvelopeFollowShowStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EnvelopeFollowShowStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EnvelopeFollowShowStatus {
    fn default() -> Self {
        EnvelopeFollowShowStatus::EnvelopeFollowShowUnknown
    }
}

impl EnvelopeFollowShowStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EnvelopeFollowShowStatus>("EnvelopeFollowShowStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TikTok.EnvelopeDisplay)
pub enum EnvelopeDisplay {
    // @@protoc_insertion_point(enum_value:TikTok.EnvelopeDisplay.EnvelopeDisplayUnknown)
    EnvelopeDisplayUnknown = 0,
    // @@protoc_insertion_point(enum_value:TikTok.EnvelopeDisplay.EnvelopeDisplayNew)
    EnvelopeDisplayNew = 1,
    // @@protoc_insertion_point(enum_value:TikTok.EnvelopeDisplay.EnvelopeDisplayHide)
    EnvelopeDisplayHide = 2,
}

impl ::protobuf::Enum for EnvelopeDisplay {
    const NAME: &'static str = "EnvelopeDisplay";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EnvelopeDisplay> {
        match value {
            0 => ::std::option::Option::Some(EnvelopeDisplay::EnvelopeDisplayUnknown),
            1 => ::std::option::Option::Some(EnvelopeDisplay::EnvelopeDisplayNew),
            2 => ::std::option::Option::Some(EnvelopeDisplay::EnvelopeDisplayHide),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EnvelopeDisplay> {
        match str {
            "EnvelopeDisplayUnknown" => ::std::option::Option::Some(EnvelopeDisplay::EnvelopeDisplayUnknown),
            "EnvelopeDisplayNew" => ::std::option::Option::Some(EnvelopeDisplay::EnvelopeDisplayNew),
            "EnvelopeDisplayHide" => ::std::option::Option::Some(EnvelopeDisplay::EnvelopeDisplayHide),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EnvelopeDisplay] = &[
        EnvelopeDisplay::EnvelopeDisplayUnknown,
        EnvelopeDisplay::EnvelopeDisplayNew,
        EnvelopeDisplay::EnvelopeDisplayHide,
    ];
}

impl ::protobuf::EnumFull for EnvelopeDisplay {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EnvelopeDisplay").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EnvelopeDisplay {
    fn default() -> Self {
        EnvelopeDisplay::EnvelopeDisplayUnknown
    }
}

impl EnvelopeDisplay {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EnvelopeDisplay>("EnvelopeDisplay")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TikTok.CommonContentCase)
pub enum CommonContentCase {
    // @@protoc_insertion_point(enum_value:TikTok.CommonContentCase.COMMON_CONTENT_NOT_SET)
    COMMON_CONTENT_NOT_SET = 0,
    // @@protoc_insertion_point(enum_value:TikTok.CommonContentCase.CREATE_CHANNEL_CONTENT)
    CREATE_CHANNEL_CONTENT = 100,
    // @@protoc_insertion_point(enum_value:TikTok.CommonContentCase.LIST_CHANGE_CONTENT)
    LIST_CHANGE_CONTENT = 102,
    // @@protoc_insertion_point(enum_value:TikTok.CommonContentCase.INVITE_CONTENT)
    INVITE_CONTENT = 103,
    // @@protoc_insertion_point(enum_value:TikTok.CommonContentCase.APPLY_CONTENT)
    APPLY_CONTENT = 104,
    // @@protoc_insertion_point(enum_value:TikTok.CommonContentCase.PERMIT_APPLY_CONTENT)
    PERMIT_APPLY_CONTENT = 105,
    // @@protoc_insertion_point(enum_value:TikTok.CommonContentCase.REPLY_INVITE_CONTENT)
    REPLY_INVITE_CONTENT = 106,
    // @@protoc_insertion_point(enum_value:TikTok.CommonContentCase.KICK_OUT_CONTENT)
    KICK_OUT_CONTENT = 107,
    // @@protoc_insertion_point(enum_value:TikTok.CommonContentCase.CANCEL_APPLY_CONTENT)
    CANCEL_APPLY_CONTENT = 108,
    // @@protoc_insertion_point(enum_value:TikTok.CommonContentCase.CANCEL_INVITE_CONTENT)
    CANCEL_INVITE_CONTENT = 109,
    // @@protoc_insertion_point(enum_value:TikTok.CommonContentCase.LEAVE_CONTENT)
    LEAVE_CONTENT = 110,
    // @@protoc_insertion_point(enum_value:TikTok.CommonContentCase.FINISH_CONTENT)
    FINISH_CONTENT = 111,
    // @@protoc_insertion_point(enum_value:TikTok.CommonContentCase.JOIN_DIRECT_CONTENT)
    JOIN_DIRECT_CONTENT = 112,
    // @@protoc_insertion_point(enum_value:TikTok.CommonContentCase.JOIN_GROUP_CONTENT)
    JOIN_GROUP_CONTENT = 113,
    // @@protoc_insertion_point(enum_value:TikTok.CommonContentCase.PERMIT_GROUP_CONTENT)
    PERMIT_GROUP_CONTENT = 114,
    // @@protoc_insertion_point(enum_value:TikTok.CommonContentCase.CANCEL_GROUP_CONTENT)
    CANCEL_GROUP_CONTENT = 115,
    // @@protoc_insertion_point(enum_value:TikTok.CommonContentCase.LEAVE_GROUP_CONTENT)
    LEAVE_GROUP_CONTENT = 116,
    // @@protoc_insertion_point(enum_value:TikTok.CommonContentCase.P2P_GROUP_CHANGE_CONTENT)
    P2P_GROUP_CHANGE_CONTENT = 117,
    // @@protoc_insertion_point(enum_value:TikTok.CommonContentCase.GROUP_CHANGE_CONTENT)
    GROUP_CHANGE_CONTENT = 118,
}

impl ::protobuf::Enum for CommonContentCase {
    const NAME: &'static str = "CommonContentCase";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CommonContentCase> {
        match value {
            0 => ::std::option::Option::Some(CommonContentCase::COMMON_CONTENT_NOT_SET),
            100 => ::std::option::Option::Some(CommonContentCase::CREATE_CHANNEL_CONTENT),
            102 => ::std::option::Option::Some(CommonContentCase::LIST_CHANGE_CONTENT),
            103 => ::std::option::Option::Some(CommonContentCase::INVITE_CONTENT),
            104 => ::std::option::Option::Some(CommonContentCase::APPLY_CONTENT),
            105 => ::std::option::Option::Some(CommonContentCase::PERMIT_APPLY_CONTENT),
            106 => ::std::option::Option::Some(CommonContentCase::REPLY_INVITE_CONTENT),
            107 => ::std::option::Option::Some(CommonContentCase::KICK_OUT_CONTENT),
            108 => ::std::option::Option::Some(CommonContentCase::CANCEL_APPLY_CONTENT),
            109 => ::std::option::Option::Some(CommonContentCase::CANCEL_INVITE_CONTENT),
            110 => ::std::option::Option::Some(CommonContentCase::LEAVE_CONTENT),
            111 => ::std::option::Option::Some(CommonContentCase::FINISH_CONTENT),
            112 => ::std::option::Option::Some(CommonContentCase::JOIN_DIRECT_CONTENT),
            113 => ::std::option::Option::Some(CommonContentCase::JOIN_GROUP_CONTENT),
            114 => ::std::option::Option::Some(CommonContentCase::PERMIT_GROUP_CONTENT),
            115 => ::std::option::Option::Some(CommonContentCase::CANCEL_GROUP_CONTENT),
            116 => ::std::option::Option::Some(CommonContentCase::LEAVE_GROUP_CONTENT),
            117 => ::std::option::Option::Some(CommonContentCase::P2P_GROUP_CHANGE_CONTENT),
            118 => ::std::option::Option::Some(CommonContentCase::GROUP_CHANGE_CONTENT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CommonContentCase> {
        match str {
            "COMMON_CONTENT_NOT_SET" => ::std::option::Option::Some(CommonContentCase::COMMON_CONTENT_NOT_SET),
            "CREATE_CHANNEL_CONTENT" => ::std::option::Option::Some(CommonContentCase::CREATE_CHANNEL_CONTENT),
            "LIST_CHANGE_CONTENT" => ::std::option::Option::Some(CommonContentCase::LIST_CHANGE_CONTENT),
            "INVITE_CONTENT" => ::std::option::Option::Some(CommonContentCase::INVITE_CONTENT),
            "APPLY_CONTENT" => ::std::option::Option::Some(CommonContentCase::APPLY_CONTENT),
            "PERMIT_APPLY_CONTENT" => ::std::option::Option::Some(CommonContentCase::PERMIT_APPLY_CONTENT),
            "REPLY_INVITE_CONTENT" => ::std::option::Option::Some(CommonContentCase::REPLY_INVITE_CONTENT),
            "KICK_OUT_CONTENT" => ::std::option::Option::Some(CommonContentCase::KICK_OUT_CONTENT),
            "CANCEL_APPLY_CONTENT" => ::std::option::Option::Some(CommonContentCase::CANCEL_APPLY_CONTENT),
            "CANCEL_INVITE_CONTENT" => ::std::option::Option::Some(CommonContentCase::CANCEL_INVITE_CONTENT),
            "LEAVE_CONTENT" => ::std::option::Option::Some(CommonContentCase::LEAVE_CONTENT),
            "FINISH_CONTENT" => ::std::option::Option::Some(CommonContentCase::FINISH_CONTENT),
            "JOIN_DIRECT_CONTENT" => ::std::option::Option::Some(CommonContentCase::JOIN_DIRECT_CONTENT),
            "JOIN_GROUP_CONTENT" => ::std::option::Option::Some(CommonContentCase::JOIN_GROUP_CONTENT),
            "PERMIT_GROUP_CONTENT" => ::std::option::Option::Some(CommonContentCase::PERMIT_GROUP_CONTENT),
            "CANCEL_GROUP_CONTENT" => ::std::option::Option::Some(CommonContentCase::CANCEL_GROUP_CONTENT),
            "LEAVE_GROUP_CONTENT" => ::std::option::Option::Some(CommonContentCase::LEAVE_GROUP_CONTENT),
            "P2P_GROUP_CHANGE_CONTENT" => ::std::option::Option::Some(CommonContentCase::P2P_GROUP_CHANGE_CONTENT),
            "GROUP_CHANGE_CONTENT" => ::std::option::Option::Some(CommonContentCase::GROUP_CHANGE_CONTENT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CommonContentCase] = &[
        CommonContentCase::COMMON_CONTENT_NOT_SET,
        CommonContentCase::CREATE_CHANNEL_CONTENT,
        CommonContentCase::LIST_CHANGE_CONTENT,
        CommonContentCase::INVITE_CONTENT,
        CommonContentCase::APPLY_CONTENT,
        CommonContentCase::PERMIT_APPLY_CONTENT,
        CommonContentCase::REPLY_INVITE_CONTENT,
        CommonContentCase::KICK_OUT_CONTENT,
        CommonContentCase::CANCEL_APPLY_CONTENT,
        CommonContentCase::CANCEL_INVITE_CONTENT,
        CommonContentCase::LEAVE_CONTENT,
        CommonContentCase::FINISH_CONTENT,
        CommonContentCase::JOIN_DIRECT_CONTENT,
        CommonContentCase::JOIN_GROUP_CONTENT,
        CommonContentCase::PERMIT_GROUP_CONTENT,
        CommonContentCase::CANCEL_GROUP_CONTENT,
        CommonContentCase::LEAVE_GROUP_CONTENT,
        CommonContentCase::P2P_GROUP_CHANGE_CONTENT,
        CommonContentCase::GROUP_CHANGE_CONTENT,
    ];
}

impl ::protobuf::EnumFull for CommonContentCase {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CommonContentCase").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            CommonContentCase::COMMON_CONTENT_NOT_SET => 0,
            CommonContentCase::CREATE_CHANNEL_CONTENT => 1,
            CommonContentCase::LIST_CHANGE_CONTENT => 2,
            CommonContentCase::INVITE_CONTENT => 3,
            CommonContentCase::APPLY_CONTENT => 4,
            CommonContentCase::PERMIT_APPLY_CONTENT => 5,
            CommonContentCase::REPLY_INVITE_CONTENT => 6,
            CommonContentCase::KICK_OUT_CONTENT => 7,
            CommonContentCase::CANCEL_APPLY_CONTENT => 8,
            CommonContentCase::CANCEL_INVITE_CONTENT => 9,
            CommonContentCase::LEAVE_CONTENT => 10,
            CommonContentCase::FINISH_CONTENT => 11,
            CommonContentCase::JOIN_DIRECT_CONTENT => 12,
            CommonContentCase::JOIN_GROUP_CONTENT => 13,
            CommonContentCase::PERMIT_GROUP_CONTENT => 14,
            CommonContentCase::CANCEL_GROUP_CONTENT => 15,
            CommonContentCase::LEAVE_GROUP_CONTENT => 16,
            CommonContentCase::P2P_GROUP_CHANGE_CONTENT => 17,
            CommonContentCase::GROUP_CHANGE_CONTENT => 18,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CommonContentCase {
    fn default() -> Self {
        CommonContentCase::COMMON_CONTENT_NOT_SET
    }
}

impl CommonContentCase {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CommonContentCase>("CommonContentCase")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TikTok.LinkMessageType)
pub enum LinkMessageType {
    // @@protoc_insertion_point(enum_value:TikTok.LinkMessageType.TPYE_LINKER_UNKNOWN)
    TPYE_LINKER_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:TikTok.LinkMessageType.TYPE_LINKER_CREATE)
    TYPE_LINKER_CREATE = 1,
    // @@protoc_insertion_point(enum_value:TikTok.LinkMessageType.TYPE_LINKER_CLOSE)
    TYPE_LINKER_CLOSE = 2,
    // @@protoc_insertion_point(enum_value:TikTok.LinkMessageType.TYPE_LINKER_INVITE)
    TYPE_LINKER_INVITE = 3,
    // @@protoc_insertion_point(enum_value:TikTok.LinkMessageType.TYPE_LINKER_APPLY)
    TYPE_LINKER_APPLY = 4,
    // @@protoc_insertion_point(enum_value:TikTok.LinkMessageType.TYPE_LINKER_REPLY)
    TYPE_LINKER_REPLY = 5,
    // @@protoc_insertion_point(enum_value:TikTok.LinkMessageType.TPYE_LINKER_ENTER)
    TPYE_LINKER_ENTER = 6,
    // @@protoc_insertion_point(enum_value:TikTok.LinkMessageType.TPYE_LINKER_LEAVE)
    TPYE_LINKER_LEAVE = 7,
    // @@protoc_insertion_point(enum_value:TikTok.LinkMessageType.TYPE_LINKER_PERMIT)
    TYPE_LINKER_PERMIT = 8,
    // @@protoc_insertion_point(enum_value:TikTok.LinkMessageType.TPYE_LINKER_CANCEL_INVITE)
    TPYE_LINKER_CANCEL_INVITE = 9,
    // @@protoc_insertion_point(enum_value:TikTok.LinkMessageType.TYPE_LINKER_WAITING_LIST_CHANGE)
    TYPE_LINKER_WAITING_LIST_CHANGE = 10,
    // @@protoc_insertion_point(enum_value:TikTok.LinkMessageType.TYPE_LINKER_LINKED_LIST_CHANGE)
    TYPE_LINKER_LINKED_LIST_CHANGE = 11,
    // @@protoc_insertion_point(enum_value:TikTok.LinkMessageType.TYPE_LINKER_UPDATE_USER)
    TYPE_LINKER_UPDATE_USER = 12,
    // @@protoc_insertion_point(enum_value:TikTok.LinkMessageType.TPYE_LINKER_KICK_OUT)
    TPYE_LINKER_KICK_OUT = 13,
    // @@protoc_insertion_point(enum_value:TikTok.LinkMessageType.TPYE_LINKER_CANCEL_APPLY)
    TPYE_LINKER_CANCEL_APPLY = 14,
    // @@protoc_insertion_point(enum_value:TikTok.LinkMessageType.TYPE_LINKER_MUTE)
    TYPE_LINKER_MUTE = 15,
    // @@protoc_insertion_point(enum_value:TikTok.LinkMessageType.TYPE_LINKER_MATCH)
    TYPE_LINKER_MATCH = 16,
    // @@protoc_insertion_point(enum_value:TikTok.LinkMessageType.TYPE_LINKER_UPDATE_USER_SETTING)
    TYPE_LINKER_UPDATE_USER_SETTING = 17,
    // @@protoc_insertion_point(enum_value:TikTok.LinkMessageType.TYPE_LINKER_MIC_IDX_UPDATE)
    TYPE_LINKER_MIC_IDX_UPDATE = 18,
    // @@protoc_insertion_point(enum_value:TikTok.LinkMessageType.TYPE_LINKER_LEAVE_V2)
    TYPE_LINKER_LEAVE_V2 = 19,
    // @@protoc_insertion_point(enum_value:TikTok.LinkMessageType.TYPE_LINKER_WAITING_LIST_CHANGE_V2)
    TYPE_LINKER_WAITING_LIST_CHANGE_V2 = 20,
    // @@protoc_insertion_point(enum_value:TikTok.LinkMessageType.TYPE_LINKER_LINKED_LIST_CHANGE_V2)
    TYPE_LINKER_LINKED_LIST_CHANGE_V2 = 21,
    // @@protoc_insertion_point(enum_value:TikTok.LinkMessageType.TYPE_LINKER_COHOST_LIST_CHANGE)
    TYPE_LINKER_COHOST_LIST_CHANGE = 22,
    // @@protoc_insertion_point(enum_value:TikTok.LinkMessageType.TYPE_LINKER_MEDIA_CHANGE)
    TYPE_LINKER_MEDIA_CHANGE = 23,
    // @@protoc_insertion_point(enum_value:TikTok.LinkMessageType.TYPE_LINKER_ACCEPT_NOTICE)
    TYPE_LINKER_ACCEPT_NOTICE = 24,
    // @@protoc_insertion_point(enum_value:TikTok.LinkMessageType.TPYE_LINKER_SYS_KICK_OUT)
    TPYE_LINKER_SYS_KICK_OUT = 101,
    // @@protoc_insertion_point(enum_value:TikTok.LinkMessageType.TPYE_LINKMIC_USER_TOAST)
    TPYE_LINKMIC_USER_TOAST = 102,
}

impl ::protobuf::Enum for LinkMessageType {
    const NAME: &'static str = "LinkMessageType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LinkMessageType> {
        match value {
            0 => ::std::option::Option::Some(LinkMessageType::TPYE_LINKER_UNKNOWN),
            1 => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_CREATE),
            2 => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_CLOSE),
            3 => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_INVITE),
            4 => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_APPLY),
            5 => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_REPLY),
            6 => ::std::option::Option::Some(LinkMessageType::TPYE_LINKER_ENTER),
            7 => ::std::option::Option::Some(LinkMessageType::TPYE_LINKER_LEAVE),
            8 => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_PERMIT),
            9 => ::std::option::Option::Some(LinkMessageType::TPYE_LINKER_CANCEL_INVITE),
            10 => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_WAITING_LIST_CHANGE),
            11 => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_LINKED_LIST_CHANGE),
            12 => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_UPDATE_USER),
            13 => ::std::option::Option::Some(LinkMessageType::TPYE_LINKER_KICK_OUT),
            14 => ::std::option::Option::Some(LinkMessageType::TPYE_LINKER_CANCEL_APPLY),
            15 => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_MUTE),
            16 => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_MATCH),
            17 => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_UPDATE_USER_SETTING),
            18 => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_MIC_IDX_UPDATE),
            19 => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_LEAVE_V2),
            20 => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_WAITING_LIST_CHANGE_V2),
            21 => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_LINKED_LIST_CHANGE_V2),
            22 => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_COHOST_LIST_CHANGE),
            23 => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_MEDIA_CHANGE),
            24 => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_ACCEPT_NOTICE),
            101 => ::std::option::Option::Some(LinkMessageType::TPYE_LINKER_SYS_KICK_OUT),
            102 => ::std::option::Option::Some(LinkMessageType::TPYE_LINKMIC_USER_TOAST),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<LinkMessageType> {
        match str {
            "TPYE_LINKER_UNKNOWN" => ::std::option::Option::Some(LinkMessageType::TPYE_LINKER_UNKNOWN),
            "TYPE_LINKER_CREATE" => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_CREATE),
            "TYPE_LINKER_CLOSE" => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_CLOSE),
            "TYPE_LINKER_INVITE" => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_INVITE),
            "TYPE_LINKER_APPLY" => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_APPLY),
            "TYPE_LINKER_REPLY" => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_REPLY),
            "TPYE_LINKER_ENTER" => ::std::option::Option::Some(LinkMessageType::TPYE_LINKER_ENTER),
            "TPYE_LINKER_LEAVE" => ::std::option::Option::Some(LinkMessageType::TPYE_LINKER_LEAVE),
            "TYPE_LINKER_PERMIT" => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_PERMIT),
            "TPYE_LINKER_CANCEL_INVITE" => ::std::option::Option::Some(LinkMessageType::TPYE_LINKER_CANCEL_INVITE),
            "TYPE_LINKER_WAITING_LIST_CHANGE" => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_WAITING_LIST_CHANGE),
            "TYPE_LINKER_LINKED_LIST_CHANGE" => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_LINKED_LIST_CHANGE),
            "TYPE_LINKER_UPDATE_USER" => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_UPDATE_USER),
            "TPYE_LINKER_KICK_OUT" => ::std::option::Option::Some(LinkMessageType::TPYE_LINKER_KICK_OUT),
            "TPYE_LINKER_CANCEL_APPLY" => ::std::option::Option::Some(LinkMessageType::TPYE_LINKER_CANCEL_APPLY),
            "TYPE_LINKER_MUTE" => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_MUTE),
            "TYPE_LINKER_MATCH" => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_MATCH),
            "TYPE_LINKER_UPDATE_USER_SETTING" => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_UPDATE_USER_SETTING),
            "TYPE_LINKER_MIC_IDX_UPDATE" => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_MIC_IDX_UPDATE),
            "TYPE_LINKER_LEAVE_V2" => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_LEAVE_V2),
            "TYPE_LINKER_WAITING_LIST_CHANGE_V2" => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_WAITING_LIST_CHANGE_V2),
            "TYPE_LINKER_LINKED_LIST_CHANGE_V2" => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_LINKED_LIST_CHANGE_V2),
            "TYPE_LINKER_COHOST_LIST_CHANGE" => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_COHOST_LIST_CHANGE),
            "TYPE_LINKER_MEDIA_CHANGE" => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_MEDIA_CHANGE),
            "TYPE_LINKER_ACCEPT_NOTICE" => ::std::option::Option::Some(LinkMessageType::TYPE_LINKER_ACCEPT_NOTICE),
            "TPYE_LINKER_SYS_KICK_OUT" => ::std::option::Option::Some(LinkMessageType::TPYE_LINKER_SYS_KICK_OUT),
            "TPYE_LINKMIC_USER_TOAST" => ::std::option::Option::Some(LinkMessageType::TPYE_LINKMIC_USER_TOAST),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LinkMessageType] = &[
        LinkMessageType::TPYE_LINKER_UNKNOWN,
        LinkMessageType::TYPE_LINKER_CREATE,
        LinkMessageType::TYPE_LINKER_CLOSE,
        LinkMessageType::TYPE_LINKER_INVITE,
        LinkMessageType::TYPE_LINKER_APPLY,
        LinkMessageType::TYPE_LINKER_REPLY,
        LinkMessageType::TPYE_LINKER_ENTER,
        LinkMessageType::TPYE_LINKER_LEAVE,
        LinkMessageType::TYPE_LINKER_PERMIT,
        LinkMessageType::TPYE_LINKER_CANCEL_INVITE,
        LinkMessageType::TYPE_LINKER_WAITING_LIST_CHANGE,
        LinkMessageType::TYPE_LINKER_LINKED_LIST_CHANGE,
        LinkMessageType::TYPE_LINKER_UPDATE_USER,
        LinkMessageType::TPYE_LINKER_KICK_OUT,
        LinkMessageType::TPYE_LINKER_CANCEL_APPLY,
        LinkMessageType::TYPE_LINKER_MUTE,
        LinkMessageType::TYPE_LINKER_MATCH,
        LinkMessageType::TYPE_LINKER_UPDATE_USER_SETTING,
        LinkMessageType::TYPE_LINKER_MIC_IDX_UPDATE,
        LinkMessageType::TYPE_LINKER_LEAVE_V2,
        LinkMessageType::TYPE_LINKER_WAITING_LIST_CHANGE_V2,
        LinkMessageType::TYPE_LINKER_LINKED_LIST_CHANGE_V2,
        LinkMessageType::TYPE_LINKER_COHOST_LIST_CHANGE,
        LinkMessageType::TYPE_LINKER_MEDIA_CHANGE,
        LinkMessageType::TYPE_LINKER_ACCEPT_NOTICE,
        LinkMessageType::TPYE_LINKER_SYS_KICK_OUT,
        LinkMessageType::TPYE_LINKMIC_USER_TOAST,
    ];
}

impl ::protobuf::EnumFull for LinkMessageType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("LinkMessageType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            LinkMessageType::TPYE_LINKER_UNKNOWN => 0,
            LinkMessageType::TYPE_LINKER_CREATE => 1,
            LinkMessageType::TYPE_LINKER_CLOSE => 2,
            LinkMessageType::TYPE_LINKER_INVITE => 3,
            LinkMessageType::TYPE_LINKER_APPLY => 4,
            LinkMessageType::TYPE_LINKER_REPLY => 5,
            LinkMessageType::TPYE_LINKER_ENTER => 6,
            LinkMessageType::TPYE_LINKER_LEAVE => 7,
            LinkMessageType::TYPE_LINKER_PERMIT => 8,
            LinkMessageType::TPYE_LINKER_CANCEL_INVITE => 9,
            LinkMessageType::TYPE_LINKER_WAITING_LIST_CHANGE => 10,
            LinkMessageType::TYPE_LINKER_LINKED_LIST_CHANGE => 11,
            LinkMessageType::TYPE_LINKER_UPDATE_USER => 12,
            LinkMessageType::TPYE_LINKER_KICK_OUT => 13,
            LinkMessageType::TPYE_LINKER_CANCEL_APPLY => 14,
            LinkMessageType::TYPE_LINKER_MUTE => 15,
            LinkMessageType::TYPE_LINKER_MATCH => 16,
            LinkMessageType::TYPE_LINKER_UPDATE_USER_SETTING => 17,
            LinkMessageType::TYPE_LINKER_MIC_IDX_UPDATE => 18,
            LinkMessageType::TYPE_LINKER_LEAVE_V2 => 19,
            LinkMessageType::TYPE_LINKER_WAITING_LIST_CHANGE_V2 => 20,
            LinkMessageType::TYPE_LINKER_LINKED_LIST_CHANGE_V2 => 21,
            LinkMessageType::TYPE_LINKER_COHOST_LIST_CHANGE => 22,
            LinkMessageType::TYPE_LINKER_MEDIA_CHANGE => 23,
            LinkMessageType::TYPE_LINKER_ACCEPT_NOTICE => 24,
            LinkMessageType::TPYE_LINKER_SYS_KICK_OUT => 25,
            LinkMessageType::TPYE_LINKMIC_USER_TOAST => 26,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for LinkMessageType {
    fn default() -> Self {
        LinkMessageType::TPYE_LINKER_UNKNOWN
    }
}

impl LinkMessageType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LinkMessageType>("LinkMessageType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TikTok.MessageType)
pub enum MessageType {
    // @@protoc_insertion_point(enum_value:TikTok.MessageType.MESSAGETYPE_SUBSUCCESS)
    MESSAGETYPE_SUBSUCCESS = 0,
    // @@protoc_insertion_point(enum_value:TikTok.MessageType.MESSAGETYPE_ANCHORREMINDER)
    MESSAGETYPE_ANCHORREMINDER = 1,
    // @@protoc_insertion_point(enum_value:TikTok.MessageType.MESSAGETYPE_ENTERROOMEXPIRESOON)
    MESSAGETYPE_ENTERROOMEXPIRESOON = 2,
    // @@protoc_insertion_point(enum_value:TikTok.MessageType.MESSAGETYPE_SUBGOALCREATETOANCHOR)
    MESSAGETYPE_SUBGOALCREATETOANCHOR = 3,
    // @@protoc_insertion_point(enum_value:TikTok.MessageType.MESSAGETYPE_SUBGOALCOMPLETETOAUDIENCE)
    MESSAGETYPE_SUBGOALCOMPLETETOAUDIENCE = 4,
    // @@protoc_insertion_point(enum_value:TikTok.MessageType.MESSAGETYPE_SUBGOALCOMPLETETOANCHOR)
    MESSAGETYPE_SUBGOALCOMPLETETOANCHOR = 5,
    // @@protoc_insertion_point(enum_value:TikTok.MessageType.MESSAGETYPE_SUBGIFTTIKTOK2USERNOTICE)
    MESSAGETYPE_SUBGIFTTIKTOK2USERNOTICE = 6,
    // @@protoc_insertion_point(enum_value:TikTok.MessageType.MESSAGETYPE_SUBGIFTTIKTOK2ANCHORNOTICE)
    MESSAGETYPE_SUBGIFTTIKTOK2ANCHORNOTICE = 7,
    // @@protoc_insertion_point(enum_value:TikTok.MessageType.MESSAGETYPE_SUBGIFTTRECEIVESENDNOTICE)
    MESSAGETYPE_SUBGIFTTRECEIVESENDNOTICE = 8,
    // @@protoc_insertion_point(enum_value:TikTok.MessageType.MESSAGETYPE_SUBGIFTSENDSUCCEEDROOMMESSAGE)
    MESSAGETYPE_SUBGIFTSENDSUCCEEDROOMMESSAGE = 9,
    // @@protoc_insertion_point(enum_value:TikTok.MessageType.MESSAGETYPE_SUBGIFTSENDSUCCEEDANCHORNOTICE)
    MESSAGETYPE_SUBGIFTSENDSUCCEEDANCHORNOTICE = 10,
    // @@protoc_insertion_point(enum_value:TikTok.MessageType.MESSAGETYPE_SUBGIFTLOWVERSIONUPGRADENOTICE)
    MESSAGETYPE_SUBGIFTLOWVERSIONUPGRADENOTICE = 11,
    // @@protoc_insertion_point(enum_value:TikTok.MessageType.MESSAGETYPE_SUBGIFTUSERBUYAUTHNOTICE)
    MESSAGETYPE_SUBGIFTUSERBUYAUTHNOTICE = 12,
}

impl ::protobuf::Enum for MessageType {
    const NAME: &'static str = "MessageType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MessageType> {
        match value {
            0 => ::std::option::Option::Some(MessageType::MESSAGETYPE_SUBSUCCESS),
            1 => ::std::option::Option::Some(MessageType::MESSAGETYPE_ANCHORREMINDER),
            2 => ::std::option::Option::Some(MessageType::MESSAGETYPE_ENTERROOMEXPIRESOON),
            3 => ::std::option::Option::Some(MessageType::MESSAGETYPE_SUBGOALCREATETOANCHOR),
            4 => ::std::option::Option::Some(MessageType::MESSAGETYPE_SUBGOALCOMPLETETOAUDIENCE),
            5 => ::std::option::Option::Some(MessageType::MESSAGETYPE_SUBGOALCOMPLETETOANCHOR),
            6 => ::std::option::Option::Some(MessageType::MESSAGETYPE_SUBGIFTTIKTOK2USERNOTICE),
            7 => ::std::option::Option::Some(MessageType::MESSAGETYPE_SUBGIFTTIKTOK2ANCHORNOTICE),
            8 => ::std::option::Option::Some(MessageType::MESSAGETYPE_SUBGIFTTRECEIVESENDNOTICE),
            9 => ::std::option::Option::Some(MessageType::MESSAGETYPE_SUBGIFTSENDSUCCEEDROOMMESSAGE),
            10 => ::std::option::Option::Some(MessageType::MESSAGETYPE_SUBGIFTSENDSUCCEEDANCHORNOTICE),
            11 => ::std::option::Option::Some(MessageType::MESSAGETYPE_SUBGIFTLOWVERSIONUPGRADENOTICE),
            12 => ::std::option::Option::Some(MessageType::MESSAGETYPE_SUBGIFTUSERBUYAUTHNOTICE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<MessageType> {
        match str {
            "MESSAGETYPE_SUBSUCCESS" => ::std::option::Option::Some(MessageType::MESSAGETYPE_SUBSUCCESS),
            "MESSAGETYPE_ANCHORREMINDER" => ::std::option::Option::Some(MessageType::MESSAGETYPE_ANCHORREMINDER),
            "MESSAGETYPE_ENTERROOMEXPIRESOON" => ::std::option::Option::Some(MessageType::MESSAGETYPE_ENTERROOMEXPIRESOON),
            "MESSAGETYPE_SUBGOALCREATETOANCHOR" => ::std::option::Option::Some(MessageType::MESSAGETYPE_SUBGOALCREATETOANCHOR),
            "MESSAGETYPE_SUBGOALCOMPLETETOAUDIENCE" => ::std::option::Option::Some(MessageType::MESSAGETYPE_SUBGOALCOMPLETETOAUDIENCE),
            "MESSAGETYPE_SUBGOALCOMPLETETOANCHOR" => ::std::option::Option::Some(MessageType::MESSAGETYPE_SUBGOALCOMPLETETOANCHOR),
            "MESSAGETYPE_SUBGIFTTIKTOK2USERNOTICE" => ::std::option::Option::Some(MessageType::MESSAGETYPE_SUBGIFTTIKTOK2USERNOTICE),
            "MESSAGETYPE_SUBGIFTTIKTOK2ANCHORNOTICE" => ::std::option::Option::Some(MessageType::MESSAGETYPE_SUBGIFTTIKTOK2ANCHORNOTICE),
            "MESSAGETYPE_SUBGIFTTRECEIVESENDNOTICE" => ::std::option::Option::Some(MessageType::MESSAGETYPE_SUBGIFTTRECEIVESENDNOTICE),
            "MESSAGETYPE_SUBGIFTSENDSUCCEEDROOMMESSAGE" => ::std::option::Option::Some(MessageType::MESSAGETYPE_SUBGIFTSENDSUCCEEDROOMMESSAGE),
            "MESSAGETYPE_SUBGIFTSENDSUCCEEDANCHORNOTICE" => ::std::option::Option::Some(MessageType::MESSAGETYPE_SUBGIFTSENDSUCCEEDANCHORNOTICE),
            "MESSAGETYPE_SUBGIFTLOWVERSIONUPGRADENOTICE" => ::std::option::Option::Some(MessageType::MESSAGETYPE_SUBGIFTLOWVERSIONUPGRADENOTICE),
            "MESSAGETYPE_SUBGIFTUSERBUYAUTHNOTICE" => ::std::option::Option::Some(MessageType::MESSAGETYPE_SUBGIFTUSERBUYAUTHNOTICE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MessageType] = &[
        MessageType::MESSAGETYPE_SUBSUCCESS,
        MessageType::MESSAGETYPE_ANCHORREMINDER,
        MessageType::MESSAGETYPE_ENTERROOMEXPIRESOON,
        MessageType::MESSAGETYPE_SUBGOALCREATETOANCHOR,
        MessageType::MESSAGETYPE_SUBGOALCOMPLETETOAUDIENCE,
        MessageType::MESSAGETYPE_SUBGOALCOMPLETETOANCHOR,
        MessageType::MESSAGETYPE_SUBGIFTTIKTOK2USERNOTICE,
        MessageType::MESSAGETYPE_SUBGIFTTIKTOK2ANCHORNOTICE,
        MessageType::MESSAGETYPE_SUBGIFTTRECEIVESENDNOTICE,
        MessageType::MESSAGETYPE_SUBGIFTSENDSUCCEEDROOMMESSAGE,
        MessageType::MESSAGETYPE_SUBGIFTSENDSUCCEEDANCHORNOTICE,
        MessageType::MESSAGETYPE_SUBGIFTLOWVERSIONUPGRADENOTICE,
        MessageType::MESSAGETYPE_SUBGIFTUSERBUYAUTHNOTICE,
    ];
}

impl ::protobuf::EnumFull for MessageType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MessageType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MessageType {
    fn default() -> Self {
        MessageType::MESSAGETYPE_SUBSUCCESS
    }
}

impl MessageType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MessageType>("MessageType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TikTok.Scene)
pub enum Scene {
    // @@protoc_insertion_point(enum_value:TikTok.Scene.SCENE_UNKNOWN)
    SCENE_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:TikTok.Scene.SCENE_CO_HOST)
    SCENE_CO_HOST = 2,
    // @@protoc_insertion_point(enum_value:TikTok.Scene.SCENE_MULTI_LIVE)
    SCENE_MULTI_LIVE = 4,
}

impl ::protobuf::Enum for Scene {
    const NAME: &'static str = "Scene";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Scene> {
        match value {
            0 => ::std::option::Option::Some(Scene::SCENE_UNKNOWN),
            2 => ::std::option::Option::Some(Scene::SCENE_CO_HOST),
            4 => ::std::option::Option::Some(Scene::SCENE_MULTI_LIVE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Scene> {
        match str {
            "SCENE_UNKNOWN" => ::std::option::Option::Some(Scene::SCENE_UNKNOWN),
            "SCENE_CO_HOST" => ::std::option::Option::Some(Scene::SCENE_CO_HOST),
            "SCENE_MULTI_LIVE" => ::std::option::Option::Some(Scene::SCENE_MULTI_LIVE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Scene] = &[
        Scene::SCENE_UNKNOWN,
        Scene::SCENE_CO_HOST,
        Scene::SCENE_MULTI_LIVE,
    ];
}

impl ::protobuf::EnumFull for Scene {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Scene").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            Scene::SCENE_UNKNOWN => 0,
            Scene::SCENE_CO_HOST => 1,
            Scene::SCENE_MULTI_LIVE => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Scene {
    fn default() -> Self {
        Scene::SCENE_UNKNOWN
    }
}

impl Scene {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Scene>("Scene")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0benums.proto\x12\x06TikTok*\x85\x01\n\x0bAuditStatus\x12\x16\n\x12A\
    UDITSTATUSUNKNOWN\x10\0\x12\x13\n\x0fAUDITSTATUSPASS\x10\x01\x12\x15\n\
    \x11AUDITSTATUSFAILED\x10\x02\x12\x18\n\x14AUDITSTATUSREVIEWING\x10\x03\
    \x12\x18\n\x14AUDITSTATUSFORBIDDEN\x10\x04*:\n\tEmoteType\x12\x13\n\x0fE\
    MOTETYPENORMAL\x10\0\x12\x18\n\x14EMOTETYPEWITHSTICKER\x10\x01*[\n\rCont\
    entSource\x12\x18\n\x14CONTENTSOURCEUNKNOWN\x10\0\x12\x17\n\x13CONTENTSO\
    URCENORMAL\x10\x01\x12\x17\n\x13CONTENTSOURCECAMERA\x10\x02*R\n\x10Emote\
    PrivateType\x12\x1d\n\x19EMOTE_PRIVATE_TYPE_NORMAL\x10\0\x12\x1f\n\x1bEM\
    OTE_PRIVATE_TYPE_SUB_WAVE\x10\x01*)\n\x08TextType\x12\x10\n\x0cDISPLAY_T\
    EXT\x10\0\x12\x0b\n\x07CONTENT\x10\x01*r\n\x19LinkmicApplierSortSetting\
    \x12%\n!LINKMIC_APPLIER_SORT_SETTING_NONE\x10\0\x12.\n*LINKMIC_APPLIER_S\
    ORT_SETTING_BY_GIFT_SCORE\x10\x01**\n\x10HashtagNamespace\x12\n\n\x06GLO\
    BAL\x10\0\x12\n\n\x06GAMING\x10\x01*7\n\x0bAgreeStatus\x12\x11\n\rAGREE_\
    UNKNOWN\x10\0\x12\t\n\x05AGREE\x10\x01\x12\n\n\x06REJECT\x10\x02*\xfd\
    \x01\n\rKickoutReason\x12\x1a\n\x16KICKOUT_REASON_UNKNOWN\x10\0\x12&\n\"\
    KICKOUT_REASON_FIRST_FRAME_TIMEOUT\x10\x01\x12\x1a\n\x16KICKOUT_REASON_B\
    Y_HOST\x10\x02\x12&\n\"KICKOUT_REASON_RTC_LOST_CONNECTION\x10\x03\x12\
    \x1c\n\x18KICKOUT_REASON_BY_PUNISH\x10\x04\x12\x1b\n\x17KICKOUT_REASON_B\
    Y_ADMIN\x10\x05\x12)\n%KICKOUT_REASON_HOST_REMOVE_ALL_GUESTS\x10\x06*Z\n\
    \x0bGroupStatus\x12\x18\n\x14GROUP_STATUS_UNKNOWN\x10\0\x12\x18\n\x14GRO\
    UP_STATUS_WAITING\x10\x01\x12\x17\n\x13GROUP_STATUS_LINKED\x10\x03*\x83\
    \x02\n\x0cBusinessCase\x12\x14\n\x10BUSINESS_NOT_SET\x10\0\x12\x15\n\x11\
    APPLY_BIZ_CONTENT\x10\x01\x12\x16\n\x12INVITE_BIZ_CONTENT\x10\x02\x12\
    \x15\n\x11REPLY_BIZ_CONTENT\x10\x03\x12\x16\n\x12PERMIT_BIZ_CONTENT\x10\
    \x04\x12\x1b\n\x17JOIN_DIRECT_BIZ_CONTENT\x10\x05\x12\x18\n\x14KICK_OUT_\
    BIZ_CONTENT\x10\x06\x12\x1b\n\x17LIST_CHANGE_BIZ_CONTENT\x10\x0b\x12\x16\
    \n\x12MULTI_LIVE_CONTENT\x10d\x12\x13\n\x0eCOHOST_CONTENT\x10\xc8\x01*\
    \xae\x08\n\x0bReplyStatus\x12\x18\n\x14REPLY_STATUS_UNKNOWN\x10\0\x12\
    \x16\n\x12REPLY_STATUS_AGREE\x10\x01\x12\"\n\x1eREPLY_STATUS_REFUSE_PERS\
    ONALLY\x10\x02\x12(\n$REPLY_STATUS_REFUSE_TYPE_NOT_SUPPORT\x10\x03\x12-\
    \n)REPLY_STATUS_REFUSE_PROCESSING_INVITATION\x10\x04\x12\"\n\x1eREPLY_ST\
    ATUS_REFUSE_BY_TIMEOUT\x10\x05\x12!\n\x1dREPLY_STATUS_REFUSE_EXCEPTION\
    \x10\x06\x12,\n(REPLY_STATUS_REFUSE_SYSTEM_NOT_SUPPORTED\x10\x07\x12*\n&\
    REPLY_STATUS_REFUSE_SUBTYPE_DIFFERENCE\x10\x08\x12\"\n\x1eREPLY_STATUS_R\
    EFUSE_IN_MICROOM\x10\t\x12'\n#REPLY_STATUS_REFUSE_NOT_LOAD_PLUGIN\x10\n\
    \x12&\n\"REPLY_STATUS_REFUSE_IN_MULTI_GUEST\x10\x0b\x12\"\n\x1eREPLY_STA\
    TUS_REFUSE_PAUSE_LIVE\x10\x0c\x122\n.REPLY_STATUS_REFUSE_OPEN_CAMERA_DIA\
    LOG_SHOWING\x10\r\x12%\n!REPLY_STATUS_REFUSE_DRAW_GUESSING\x10\x0e\x12'\
    \n#REPLY_STATUS_REFUSE_RANDOM_MATCHING\x10\x0f\x12+\n'REPLY_STATUS_REFUS\
    E_IN_MATCH_PROCESSING\x10\x10\x123\n/REPLY_STATUS_REFUSE_IN_MICROOM_FOR_\
    MULTI_COHOST\x10\x11\x12'\n#REPLY_STATUS_REFUSE_COHOST_FINISHED\x10\x12\
    \x12%\n!REPLY_STATUS_REFUSE_NOT_CONNECTED\x10\x13\x12$\n\x20REPLY_STATUS\
    _REFUSE_LINKMIC_FULL\x10\x14\x12(\n$REPLY_STATUS_REFUSE_ARC_INCOMPATIBLE\
    \x10\x15\x12/\n+REPLY_STATUS_REFUSE_PROCESSING_OTHER_INVITE\x10\x16\x12.\
    \n*REPLY_STATUS_REFUSE_PROCESSING_OTHER_APPLY\x10\x17\x12(\n$REPLY_STATU\
    S_REFUSE_IN_ANCHOR_COHOST\x10\x18\x12%\n!REPLY_STATUS_REFUSE_TOPIC_PAIRI\
    NG\x10\x19*Z\n\rSubscribeType\x12\x16\n\x12SUBSCRIBETYPE_ONCE\x10\0\x12\
    \x16\n\x12SUBSCRIBETYPE_AUTO\x10\x01\x12\x19\n\x15SUBSCRIBETYPE_DEFAULT\
    \x10d*\xc5\x01\n\x12OldSubscribeStatus\x12\x1c\n\x18OLDSUBSCRIBESTATUS_F\
    IRST\x10\0\x12\x1c\n\x18OLDSUBSCRIBESTATUS_RESUB\x10\x01\x12'\n#OLDSUBSC\
    RIBESTATUS_SUBINGRACEPERIOD\x10\x02\x12*\n&OLDSUBSCRIBESTATUS_SUBNOTINGR\
    ACEPERIOD\x10\x03\x12\x1e\n\x1aOLDSUBSCRIBESTATUS_DEFAULT\x10d*\xfb\x01\
    \n\x11SubscribingStatus\x12\x1d\n\x19SUBSCRIBINGSTATUS_UNKNOWN\x10\0\x12\
    \x1a\n\x16SUBSCRIBINGSTATUS_ONCE\x10\x01\x12\x1c\n\x18SUBSCRIBINGSTATUS_\
    CIRCLE\x10\x02\x12\"\n\x1eSUBSCRIBINGSTATUS_CIRCLECANCEL\x10\x03\x12\x1c\
    \n\x18SUBSCRIBINGSTATUS_REFUND\x10\x04\x12#\n\x1fSUBSCRIBINGSTATUS_INGRA\
    CEPERIOD\x10\x05\x12&\n\"SUBSCRIBINGSTATUS_NOTINGRACEPERIOD\x10\x06*q\n\
    \rLinkmicStatus\x12\x0b\n\x07Disable\x10\0\x12\n\n\x06Enable\x10\x01\x12\
    \x12\n\x0eJust_Following\x10\x02\x12\x11\n\rMulti_Linking\x10\x03\x12\
    \x20\n\x1cMulti_Linking_Only_Following\x10\x04*>\n\x13MemberMessageActio\
    n\x12\x0b\n\x07UNKNOWN\x10\0\x12\n\n\x06JOINED\x10\x01\x12\x0e\n\nSUBSCR\
    IBED\x10\x03*c\n\rControlAction\x12\x18\n\x14ControlActionUNKNOWN\x10\0\
    \x12\x11\n\rSTREAM_PAUSED\x10\x01\x12\x13\n\x0fSTREAM_UNPAUSED\x10\x02\
    \x12\x10\n\x0cSTREAM_ENDED\x10\x03*\xbb\x03\n\x14LinkLayerMessageType\
    \x12\x12\n\x0eLinker_Unknown\x10\0\x12\x11\n\rLinker_Create\x10\x01\x12\
    \x11\n\rLinker_Invite\x10\x02\x12\x10\n\x0cLinker_Apply\x10\x03\x12\x11\
    \n\rLinker_Permit\x10\x04\x12\x10\n\x0cLinker_Reply\x10\x05\x12\x13\n\
    \x0fLinker_Kick_Out\x10\x06\x12\x17\n\x13Linker_Cancel_Apply\x10\x07\x12\
    \x18\n\x14Linker_Cancel_Invite\x10\x08\x12\x10\n\x0cLinker_Leave\x10\t\
    \x12\x11\n\rLinker_Finish\x10\n\x12\x16\n\x12Linker_List_Change\x10\x0b\
    \x12\x16\n\x12Linker_Join_Direct\x10\x0c\x12\x15\n\x11Linker_Join_Group\
    \x10\r\x12\x17\n\x13Linker_Permit_Group\x10\x0e\x12\x17\n\x13Linker_Canc\
    el_Group\x10\x0f\x12\x16\n\x12Linker_Leave_Group\x10\x10\x12\x1b\n\x17Li\
    nker_P2P_Group_Change\x10\x11\x12\x17\n\x13Linker_Group_Change\x10\x12*\
    \x90\x02\n\x0bBarrageType\x12\x17\n\x13BarrageType_Unknown\x10\0\x12\x10\
    \n\x0cEComOrdering\x10\x01\x12\x0e\n\nEComBuying\x10\x02\x12\n\n\x06Norm\
    al\x10\x03\x12\r\n\tSubscribe\x10\x04\x12\r\n\tEventView\x10\x05\x12\x13\
    \n\x0fEventRegistered\x10\x06\x12\x11\n\rSubscribeGift\x10\x07\x12\x0f\n\
    \x0bUserUpgrade\x10\x08\x12!\n\x1dGradeUserEntranceNotification\x10\t\
    \x12\x14\n\x10FansLevelUpgrade\x10\n\x12\x15\n\x11FansLevelEntrance\x10\
    \x0b\x12\x13\n\x0fGamePartnership\x10\x0c*\xfb\x01\n\x14EnvelopeBusiness\
    Type\x12\x17\n\x13BusinessTypeUnknown\x10\0\x12\x1b\n\x17BusinessTypeUse\
    rDiamond\x10\x01\x12\x1f\n\x1bBusinessTypePlatformDiamond\x10\x02\x12\
    \x1d\n\x19BusinessTypePlatformShell\x10\x03\x12\x16\n\x12BusinessTypePor\
    tal\x10\x04\x12\x1d\n\x19BusinessTypePlatformMerch\x10\x05\x12\x1a\n\x16\
    BusinessTypeEoYDiamond\x10\x06\x12\x1a\n\x16BusinessTypeFanClubGtM\x10\
    \x07*l\n\x18EnvelopeFollowShowStatus\x12\x1d\n\x19EnvelopeFollowShowUnkn\
    own\x10\0\x12\x16\n\x12EnvelopeFollowShow\x10\x01\x12\x19\n\x15EnvelopeF\
    ollowNotShow\x10\x02*^\n\x0fEnvelopeDisplay\x12\x1a\n\x16EnvelopeDisplay\
    Unknown\x10\0\x12\x16\n\x12EnvelopeDisplayNew\x10\x01\x12\x17\n\x13Envel\
    opeDisplayHide\x10\x02*\xe7\x03\n\x11CommonContentCase\x12\x1a\n\x16COMM\
    ON_CONTENT_NOT_SET\x10\0\x12\x1a\n\x16CREATE_CHANNEL_CONTENT\x10d\x12\
    \x17\n\x13LIST_CHANGE_CONTENT\x10f\x12\x12\n\x0eINVITE_CONTENT\x10g\x12\
    \x11\n\rAPPLY_CONTENT\x10h\x12\x18\n\x14PERMIT_APPLY_CONTENT\x10i\x12\
    \x18\n\x14REPLY_INVITE_CONTENT\x10j\x12\x14\n\x10KICK_OUT_CONTENT\x10k\
    \x12\x18\n\x14CANCEL_APPLY_CONTENT\x10l\x12\x19\n\x15CANCEL_INVITE_CONTE\
    NT\x10m\x12\x11\n\rLEAVE_CONTENT\x10n\x12\x12\n\x0eFINISH_CONTENT\x10o\
    \x12\x17\n\x13JOIN_DIRECT_CONTENT\x10p\x12\x16\n\x12JOIN_GROUP_CONTENT\
    \x10q\x12\x18\n\x14PERMIT_GROUP_CONTENT\x10r\x12\x18\n\x14CANCEL_GROUP_C\
    ONTENT\x10s\x12\x17\n\x13LEAVE_GROUP_CONTENT\x10t\x12\x1c\n\x18P2P_GROUP\
    _CHANGE_CONTENT\x10u\x12\x18\n\x14GROUP_CHANGE_CONTENT\x10v*\x99\x06\n\
    \x0fLinkMessageType\x12\x17\n\x13TPYE_LINKER_UNKNOWN\x10\0\x12\x16\n\x12\
    TYPE_LINKER_CREATE\x10\x01\x12\x15\n\x11TYPE_LINKER_CLOSE\x10\x02\x12\
    \x16\n\x12TYPE_LINKER_INVITE\x10\x03\x12\x15\n\x11TYPE_LINKER_APPLY\x10\
    \x04\x12\x15\n\x11TYPE_LINKER_REPLY\x10\x05\x12\x15\n\x11TPYE_LINKER_ENT\
    ER\x10\x06\x12\x15\n\x11TPYE_LINKER_LEAVE\x10\x07\x12\x16\n\x12TYPE_LINK\
    ER_PERMIT\x10\x08\x12\x1d\n\x19TPYE_LINKER_CANCEL_INVITE\x10\t\x12#\n\
    \x1fTYPE_LINKER_WAITING_LIST_CHANGE\x10\n\x12\"\n\x1eTYPE_LINKER_LINKED_\
    LIST_CHANGE\x10\x0b\x12\x1b\n\x17TYPE_LINKER_UPDATE_USER\x10\x0c\x12\x18\
    \n\x14TPYE_LINKER_KICK_OUT\x10\r\x12\x1c\n\x18TPYE_LINKER_CANCEL_APPLY\
    \x10\x0e\x12\x14\n\x10TYPE_LINKER_MUTE\x10\x0f\x12\x15\n\x11TYPE_LINKER_\
    MATCH\x10\x10\x12#\n\x1fTYPE_LINKER_UPDATE_USER_SETTING\x10\x11\x12\x1e\
    \n\x1aTYPE_LINKER_MIC_IDX_UPDATE\x10\x12\x12\x18\n\x14TYPE_LINKER_LEAVE_\
    V2\x10\x13\x12&\n\"TYPE_LINKER_WAITING_LIST_CHANGE_V2\x10\x14\x12%\n!TYP\
    E_LINKER_LINKED_LIST_CHANGE_V2\x10\x15\x12\"\n\x1eTYPE_LINKER_COHOST_LIS\
    T_CHANGE\x10\x16\x12\x1c\n\x18TYPE_LINKER_MEDIA_CHANGE\x10\x17\x12\x1d\n\
    \x19TYPE_LINKER_ACCEPT_NOTICE\x10\x18\x12\x1c\n\x18TPYE_LINKER_SYS_KICK_\
    OUT\x10e\x12\x1b\n\x17TPYE_LINKMIC_USER_TOAST\x10f*\xa3\x04\n\x0bMessage\
    Type\x12\x1a\n\x16MESSAGETYPE_SUBSUCCESS\x10\0\x12\x1e\n\x1aMESSAGETYPE_\
    ANCHORREMINDER\x10\x01\x12#\n\x1fMESSAGETYPE_ENTERROOMEXPIRESOON\x10\x02\
    \x12%\n!MESSAGETYPE_SUBGOALCREATETOANCHOR\x10\x03\x12)\n%MESSAGETYPE_SUB\
    GOALCOMPLETETOAUDIENCE\x10\x04\x12'\n#MESSAGETYPE_SUBGOALCOMPLETETOANCHO\
    R\x10\x05\x12(\n$MESSAGETYPE_SUBGIFTTIKTOK2USERNOTICE\x10\x06\x12*\n&MES\
    SAGETYPE_SUBGIFTTIKTOK2ANCHORNOTICE\x10\x07\x12)\n%MESSAGETYPE_SUBGIFTTR\
    ECEIVESENDNOTICE\x10\x08\x12-\n)MESSAGETYPE_SUBGIFTSENDSUCCEEDROOMMESSAG\
    E\x10\t\x12.\n*MESSAGETYPE_SUBGIFTSENDSUCCEEDANCHORNOTICE\x10\n\x12.\n*M\
    ESSAGETYPE_SUBGIFTLOWVERSIONUPGRADENOTICE\x10\x0b\x12(\n$MESSAGETYPE_SUB\
    GIFTUSERBUYAUTHNOTICE\x10\x0c*C\n\x05Scene\x12\x11\n\rSCENE_UNKNOWN\x10\
    \0\x12\x11\n\rSCENE_CO_HOST\x10\x02\x12\x14\n\x10SCENE_MULTI_LIVE\x10\
    \x04B/\n+io.github.jwdeveloper.tiktok.messages.enumsP\x01b\x06proto3\
    ";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(0);
            let mut enums = ::std::vec::Vec::with_capacity(27);
            enums.push(AuditStatus::generated_enum_descriptor_data());
            enums.push(EmoteType::generated_enum_descriptor_data());
            enums.push(ContentSource::generated_enum_descriptor_data());
            enums.push(EmotePrivateType::generated_enum_descriptor_data());
            enums.push(TextType::generated_enum_descriptor_data());
            enums.push(LinkmicApplierSortSetting::generated_enum_descriptor_data());
            enums.push(HashtagNamespace::generated_enum_descriptor_data());
            enums.push(AgreeStatus::generated_enum_descriptor_data());
            enums.push(KickoutReason::generated_enum_descriptor_data());
            enums.push(GroupStatus::generated_enum_descriptor_data());
            enums.push(BusinessCase::generated_enum_descriptor_data());
            enums.push(ReplyStatus::generated_enum_descriptor_data());
            enums.push(SubscribeType::generated_enum_descriptor_data());
            enums.push(OldSubscribeStatus::generated_enum_descriptor_data());
            enums.push(SubscribingStatus::generated_enum_descriptor_data());
            enums.push(LinkmicStatus::generated_enum_descriptor_data());
            enums.push(MemberMessageAction::generated_enum_descriptor_data());
            enums.push(ControlAction::generated_enum_descriptor_data());
            enums.push(LinkLayerMessageType::generated_enum_descriptor_data());
            enums.push(BarrageType::generated_enum_descriptor_data());
            enums.push(EnvelopeBusinessType::generated_enum_descriptor_data());
            enums.push(EnvelopeFollowShowStatus::generated_enum_descriptor_data());
            enums.push(EnvelopeDisplay::generated_enum_descriptor_data());
            enums.push(CommonContentCase::generated_enum_descriptor_data());
            enums.push(LinkMessageType::generated_enum_descriptor_data());
            enums.push(MessageType::generated_enum_descriptor_data());
            enums.push(Scene::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
